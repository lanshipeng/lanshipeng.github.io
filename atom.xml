<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinker&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-11T09:07:20.399Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lan_shipeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/11/11/memcached/"/>
    <id>http://yoursite.com/2018/11/11/memcached/</id>
    <published>2018-11-11T03:39:55.418Z</published>
    <updated>2018-11-11T09:07:20.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="memcached’s-note"><a href="#memcached’s-note" class="headerlink" title="memcached’s note"></a>memcached’s note</h3><h4 id="save-cmd"><a href="#save-cmd" class="headerlink" title="save cmd"></a>save cmd</h4><ol><li>set key flags exptime bytes [noreply]<br> value<br> 说明：</li></ol><p>（如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。）</p><pre><code>[key]: key-value 中的key 用于查找缓存值[flags]: 包括简直对的整型参数，客户机使用它存储关于简直对的额外信息  [exptime]: 在缓存中保存键值对的时间长度 （以s为单位）  [bytes]: 缓存中字节数[noreply]: 告知服务器不需要返回数据[value]: 存储的值</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info:</p><p>– STORED：保存成功后输出。<br>– ERROR：在保存失败后输出。</p><ol start="2"><li>add key flags exptime bytes [noreply]<br> value<br> 说明：<br>（如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add new_key 0 900 10</span><br><span class="line">data_value</span><br><span class="line">STORED</span><br><span class="line">get new_key</span><br><span class="line">VALUE new_key 0 10</span><br><span class="line">data_value</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info;</p><p>– STORED：保存成功后输出。<br>– NOT_STORED ：在保存失败后输出。</p><ol start="3"><li><p>replace key flags exptime bytes [noreply]</p><p> 说明：<br>（如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add mykey 0 900 10</span><br><span class="line">data_value</span><br><span class="line">STORED</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 0 10</span><br><span class="line">data_value</span><br><span class="line">END</span><br><span class="line">replace mykey 0 900 16</span><br><span class="line">some_other_value</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 0 16</span><br><span class="line">some_other_value</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info:</p><p>– STORED：保存成功后输出。<br>– NOT_STORED：执行替换失败后输出。</p><ol start="4"><li>append key flags exptime bytes [noreply]<br> 说明：<br>（Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据 。）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line">append runoob 0 900 5</span><br><span class="line">redis</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 14</span><br><span class="line">memcachedredis</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info:<br>– STORED：保存成功后输出。<br>– NOT_STORED：该键在 Memcached 上不存在。<br>– CLIENT_ERROR：执行错误。</p><ol start="5"><li>prepend key flags exptime bytes [noreply]<br> 说明：<br>（<br>Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据 。）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line">prepend runoob 0 900 5</span><br><span class="line">redis</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 14</span><br><span class="line">redismemcached</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info:<br>– STORED：保存成功后输出。<br>– NOT_STORED：该键在 Memcached 上不存在。<br>– CLIENT_ERROR：执行错误。</p><ol start="6"><li>cas key flags exptime bytes unique_cas_token [noreply]<br>value<br>params:<br> unique_cas_token通过 gets 命令获取的一个唯一的64位值。<br>out info:<br>– STORED：保存成功后输出。<br>– ERROR：保存出错或语法错误。<br>– EXISTS：在最后一次取值后另外一个用户也在更新该数据。<br>– NOT_FOUND：Memcached 服务上不存在该键值。</li></ol><ol start="7"><li>get key</li></ol><p>说明：<br>（<br>Memcached get 命令获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。）</p><p>多个key使用空格隔开：<br>    get key1 key2 key3</p><ol start="8"><li>gets key</li></ol><p>说明：</p><p>(Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">gets runoob</span><br><span class="line">VALUE runoob 0 9 1</span><br><span class="line">memcached</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>使用 gets 命令的输出结果中，在最后一列的数字 1 代表了 key 为 runoob 的 CAS 令牌</p><ol start="9"><li>delete key [noreply]<br>说明：<br>(删除已存在的key)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line">delete runoob</span><br><span class="line">DELETED</span><br><span class="line">get runoob</span><br><span class="line">END</span><br><span class="line">delete runoob</span><br><span class="line">NOT_FOUND</span><br></pre></td></tr></table></figure></li></ol><p>out info:<br>– DELETED：删除成功。<br>– ERROR：语法错误或删除失败。<br>– NOT_FOUND：key 不存在。</p><ol start="10"><li>incr key increment_value<br>说明：<br>key：键值 key-value 结构中的 key，用于查找缓存值。<br>increment_value： 增加的数值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set visitors 0 900 2</span><br><span class="line">10</span><br><span class="line">STORED</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 2</span><br><span class="line">10</span><br><span class="line">END</span><br><span class="line">incr visitors 5</span><br><span class="line">15</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 2</span><br><span class="line">15</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set visitors 0 900 2</span><br><span class="line">10</span><br><span class="line">STORED</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 2</span><br><span class="line">10</span><br><span class="line">END</span><br><span class="line">decr visitors 5</span><br><span class="line">5</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 1</span><br><span class="line">5</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info:<br>– NOT_FOUND：key 不存在。<br>– CLIENT_ERROR：自增值不是对象。<br>– ERROR其他错误，如语法错误等。</p><h4 id="统计命令"><a href="#统计命令" class="headerlink" title="统计命令"></a>统计命令</h4><ol start="11"><li>stats<br>Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。</li></ol><ol start="12"><li><p>stats items<br>Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。</p></li><li><p>stats sizes </p></li></ol><p>Memcached stats sizes 命令用于显示所有item的大小和个数。</p><p>该信息返回两列，第一列是 item 的大小，第二列是 item 的个数。</p><ol start="14"><li>stats slabs</li></ol><p>Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。</p><ol start="15"><li>flush_all<br>Memcached flush_all 命令用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对。</li></ol><p>该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;memcached’s-note&quot;&gt;&lt;a href=&quot;#memcached’s-note&quot; class=&quot;headerlink&quot; title=&quot;memcached’s note&quot;&gt;&lt;/a&gt;memcached’s note&lt;/h3&gt;&lt;h4 id=&quot;save-cmd&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql数据库使用规范总结</title>
    <link href="http://yoursite.com/2018/10/26/sql/"/>
    <id>http://yoursite.com/2018/10/26/sql/</id>
    <published>2018-10-26T02:12:44.000Z</published>
    <updated>2018-10-26T02:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ul><li>表存储引擎设置为innodb</li><li>表字符集默认使用utf8,必要时使用utf8mb4。utf8mb4是utf8的超集,有存储4字节例如表情符号时使用他。</li><li><p>禁止数据库中存储大文件,例如照片.可以将大文件存储在对象存储系统中。数据库存储路径</p></li><li><p>一般不使用存储过程、视图、触发器,event.对数据库性能影响大，调试，排错，迁移都比较困难.拓展性差</p></li><li>对于互联网业务，能让站点层和服务层干的事,不要交到数据库</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>库名，表名,列名都必须小写,采用下划线分割</li><li>库名，表名,列名最好见名知意。长度不超过32个字符</li><li>库备份以bak为前缀，日期为后缀</li><li>从库以-s为后缀</li><li>备库以-ss为后缀</li></ul><h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><ul><li>单实例表个数控制在2000个以内</li><li>单表分表个数控制在1024个以内</li><li><p>表必须有主键，一般使用unsigned整数类型为主键  </p></li><li><p>删除无主键的表,如果是row模式的主从架构。从库会挂住</p></li><li><p>一般不使用外键,如果要保证完整性。应该由应用程式实现  </p></li><li><p>外键使得表之间相互耦合，影响update/delete性能.有可能造成死锁</p></li><li>建议将大字段,访问频率少的字段拆分到单独表中存储，分离冷热数据  </li></ul><h3 id="列设计规范"><a href="#列设计规范" class="headerlink" title="列设计规范"></a>列设计规范</h3><ul><li>根据业务区分使用tinyint/int/bigint,分别占用1/4/8字节</li><li><p>根据业务区分使用char/varchar</p></li><li><p>字段长度固定,或者长度近似的业务场景,适用char,能减少碎片,查询性能高</p></li><li>字段长度相差大，或者更新少的业务场景，适合使用varchar,可以减少空间</li><li><p>根据业务区分使用datetime/timestamp(分别占5/4字节)</p></li><li><p>把not null字段设置为默认值.因为null的列使用索引统计,值都更加复杂。更难优化。只能使用is null 或者is not null 而在=/!=/in/not in有大坑</p></li><li><p>使用int unsigned 存储ipv4 ,不要用char(15).</p></li><li>使用varchar(20)存储手机号,不要用整数</li><li>varchar可以模糊查询</li></ul><h3 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h3><ul><li>唯一索引使用uniq_[字段名]来命名</li><li>非唯一索引使用idx_[字段名]来命名</li><li><p>单张表索引数量控制在5个以内</p></li><li><p>太多索引影响写性能;生成执行计划时,如果索引太多,会降低性能.并可能导致mysql选择不到最优索引</p></li><li>组合索引字段数建议不超过5个</li><li>不建议在频繁更新的字段上建立索引</li><li>非必要不用join查询，如果要join查询,被join的字段必须类型相同,并建立索引</li><li>组合索引最前缀原则,避免重复建索引,如果建立了(a,b,c)相当于建立了(a),(a,b),(a,b,c)</li></ul><h3 id="sql书写规范"><a href="#sql书写规范" class="headerlink" title="sql书写规范"></a>sql书写规范</h3><ul><li>尽量不写select *，只获取必要字段.否则会增加cpu/io/内存/带宽的消耗</li><li>同一个字段上的or改写成in,in的值要少于50个</li><li>应用程序捕获sql异常，方便定位线上问题         </li><li>insert必须指定字段,禁止使用insert into table values()</li><li>尽量不对大表join和子查询</li></ul><h3 id="建表实例"><a href="#建表实例" class="headerlink" title="建表实例"></a>建表实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">`user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;会员信息表主键，自增长&apos;,</span><br><span class="line">`uuid` bigint(20) DEFAULT &apos;0&apos; COMMENT &apos;会员唯一标识表主键，自增长&apos;,</span><br><span class="line">`guid` bigint(20) DEFAULT &apos;0&apos; COMMENT &apos;用户中心全局ID&apos;,</span><br><span class="line">`is_certed` tinyint(4) DEFAULT &apos;2&apos; COMMENT &apos;是否认证，1 认证 2  未认证&apos;,</span><br><span class="line">`mobile` varchar(40) COLLATE utf8mb4_bin NOT NULL COMMENT &apos;手机号码&apos;,</span><br><span class="line">`last_login_tm` datetime(6) DEFAULT &apos;0000-00-00 00:00:00.000000&apos; COMMENT &apos;最后一次登录时间&apos;,</span><br><span class="line">`last_login_device` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL COMMENT &apos;最后一次登录设备号&apos;,</span><br><span class="line">`remark` varchar(250) COLLATE utf8mb4_bin DEFAULT &apos;&apos; COMMENT &apos;备注&apos;,</span><br><span class="line">`is_deleted` tinyint(4) DEFAULT &apos;1&apos; COMMENT &apos;是否删除，1 未删除，2 已删除&apos;,</span><br><span class="line">`created_tm` datetime(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT &apos;创建时间，默认是 CURRENT_TIMESTAMP(6)&apos;,</span><br><span class="line">`updated_tm` datetime(6) DEFAULT &apos;0000-00-00 00:00:00.000000&apos; ON UPDATE CURRENT_TIMESTAMP(6) COMMENT &apos;修改时间，修改时 CURRENT_TIMESTAMP(6)&apos;,</span><br><span class="line">PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=241157 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT=&apos;会员信息表&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;表存储引擎设置为innodb&lt;/li&gt;
&lt;li&gt;表字符集默认使用utf8,必要时使用utf8mb4。utf8mb
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库规范" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2018/10/25/sort/"/>
    <id>http://yoursite.com/2018/10/25/sort/</id>
    <published>2018-10-25T12:13:26.000Z</published>
    <updated>2018-10-25T12:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="golang-实现归并和堆排序"><a href="#golang-实现归并和堆排序" class="headerlink" title="golang 实现归并和堆排序"></a>golang 实现归并和堆排序</h4><p>1.归并排序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    a := make([]int,0,0)</span><br><span class="line">    r := make([]int,0,0)</span><br><span class="line">    a = []int&#123;4,1,3,2,6,5,7&#125;</span><br><span class="line">    r = []int&#123;0,0,0,0,0,0,0&#125;</span><br><span class="line">    mergesort(a,0,6,r)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">func Swap(a *int,b *int)&#123;</span><br><span class="line">    temp := *a</span><br><span class="line">    *a = *b</span><br><span class="line">    *b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func mergesort(a []int,start,end int64,result []int)&#123;</span><br><span class="line"></span><br><span class="line">    if end - start == 0&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if end - start == 1&#123;</span><br><span class="line">        if a[start] &gt; a[end]&#123;</span><br><span class="line">            Swap(&amp;a[start],&amp;a[end])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mergesort(a,start,(end-start+1)/2 + start,result)</span><br><span class="line">        mergesort(a,(end-start+1)/2 +1 + start,end,result)</span><br><span class="line">        merge(a,start,end,result)</span><br><span class="line">        var i int64 =0</span><br><span class="line">        for i=start;i&lt;=end;i++&#123;</span><br><span class="line">            a[i] = result[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func merge(a []int,start,end int64,result []int)&#123;</span><br><span class="line"></span><br><span class="line">    left_index  := start</span><br><span class="line">    left_length := (end-start+1)/2 +1</span><br><span class="line">    right_index := start + left_length</span><br><span class="line">    result_index := start</span><br><span class="line"></span><br><span class="line">    for  left_index &lt; start + left_length &amp;&amp; right_index &lt; end+1 &#123;</span><br><span class="line"></span><br><span class="line">        if a[left_index] &lt;= a[right_index]&#123;</span><br><span class="line">            result[result_index] = a[left_index]</span><br><span class="line">            result_index++</span><br><span class="line">            left_index++</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result[result_index] = a[right_index]</span><br><span class="line">            right_index++</span><br><span class="line">            result_index++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    for left_index &lt; start +left_length&#123;</span><br><span class="line">        result[result_index] = a[left_index]</span><br><span class="line">        result_index++</span><br><span class="line">        left_index++</span><br><span class="line">    &#125;</span><br><span class="line">    for right_index &lt; end+1&#123;</span><br><span class="line">        result[result_index] = a[right_index]</span><br><span class="line">        right_index++</span><br><span class="line">        result_index++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.堆排序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    a := make([]int,0,0)</span><br><span class="line">    a = []int&#123;1,4,2,3,7,9,8&#125;</span><br><span class="line">    heapsort(a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(a *int,b *int)&#123;</span><br><span class="line">    temp := *a</span><br><span class="line">    *a = *b</span><br><span class="line">    *b = temp</span><br><span class="line">&#125;</span><br><span class="line">func heapsort(a []int)&#123;</span><br><span class="line"></span><br><span class="line">    //创建大顶堆</span><br><span class="line">    var i int = 0</span><br><span class="line">    var j int = 0</span><br><span class="line">    for i= len(a)/2;i&gt;=0;i--&#123;</span><br><span class="line">        heapadjust(a,i,len(a))</span><br><span class="line">    &#125;</span><br><span class="line">    for j= len(a) -1 ;j&gt;=1;j--&#123;</span><br><span class="line">        swap(&amp;a[0],&amp;a[j])</span><br><span class="line">        heapadjust(a,0,j)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func heapadjust(a []int,i,length int)&#123;</span><br><span class="line"></span><br><span class="line">    var left int = 2*i +1</span><br><span class="line">    if left &lt; length&#123;</span><br><span class="line">        maxIndex := left</span><br><span class="line">        right := left + 1</span><br><span class="line">        if a[right] &gt; a[left] &amp;&amp; right &lt; length&#123;</span><br><span class="line">            maxIndex = right</span><br><span class="line">        &#125;</span><br><span class="line">        if a[maxIndex] &gt; a[i]&#123;</span><br><span class="line">            swap(&amp;a[maxIndex],&amp;a[i])</span><br><span class="line">            heapadjust(a,maxIndex,length)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;golang-实现归并和堆排序&quot;&gt;&lt;a href=&quot;#golang-实现归并和堆排序&quot; class=&quot;headerlink&quot; title=&quot;golang 实现归并和堆排序&quot;&gt;&lt;/a&gt;golang 实现归并和堆排序&lt;/h4&gt;&lt;p&gt;1.归并排序  &lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="http://yoursite.com/2018/10/25/list/"/>
    <id>http://yoursite.com/2018/10/25/list/</id>
    <published>2018-10-25T12:06:46.000Z</published>
    <updated>2018-10-25T12:06:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单链表的创建、插入、删除-倒置"><a href="#单链表的创建、插入、删除-倒置" class="headerlink" title="单链表的创建、插入、删除 倒置"></a>单链表的创建、插入、删除 倒置</h4><ul><li>go</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">type ListNode struct&#123;</span><br><span class="line">    value int</span><br><span class="line">    next *ListNode</span><br><span class="line">&#125;</span><br><span class="line">//创建单链表</span><br><span class="line">func (this *ListNode)CreateList()*ListNode&#123;</span><br><span class="line">    </span><br><span class="line">    head := new(ListNode)</span><br><span class="line">    ptail := new(ListNode)</span><br><span class="line">    ptail = head</span><br><span class="line">    for i :=0; i &lt;= 10; i++&#123;</span><br><span class="line">         xNode := new(ListNode)     </span><br><span class="line">         xNode.value = i</span><br><span class="line">         xNode.next = nil </span><br><span class="line">         ptail.next = xNode</span><br><span class="line">         ptail = xNode</span><br><span class="line">    &#125;</span><br><span class="line">    return phead</span><br><span class="line">&#125;</span><br><span class="line">//删除节点</span><br><span class="line">func (this *ListNode)DeleteListNod(head* ListNode,val int)&#123;  </span><br><span class="line">    if head == nil&#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp := new(ListNode)</span><br><span class="line">    p := new(ListNode)</span><br><span class="line">    p = head</span><br><span class="line">    for p.next != nil &amp;&amp; p.value != val&#123;</span><br><span class="line">        temp = p</span><br><span class="line">        p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">    if p.value == val&#123;</span><br><span class="line">        if p == head&#123;</span><br><span class="line">            head = temp.next</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp.next = p.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br><span class="line">//插入节点</span><br><span class="line">func (this *ListNode)InsertNode(head* ListNode,val int)*ListNode&#123;</span><br><span class="line">    if head == nil&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    xNode := new(ListNode)</span><br><span class="line">    xNode.value = val</span><br><span class="line">    xNode.next = nil</span><br><span class="line"></span><br><span class="line">    temp := new(ListNode)</span><br><span class="line">    p := new(ListNode)</span><br><span class="line">    p = head</span><br><span class="line">    for p.next != nil &amp;&amp; p.value &lt; val&#123;</span><br><span class="line">        temp = p</span><br><span class="line">        p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">    if p.value &lt;= val&#123;</span><br><span class="line">        if p == head&#123;</span><br><span class="line">            head = xNode</span><br><span class="line">            xNode.next = p</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp.next = xNode</span><br><span class="line">            xNode.next = p</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        p.next = xNode</span><br><span class="line">        xNode.next = nil</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br><span class="line">//链表倒置</span><br><span class="line">func (this *ListNode)Reverse(head* ListNode)*ListNode&#123;</span><br><span class="line">    if head==nil&#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    temp := new(ListNode)</span><br><span class="line">    p := new(ListNode)</span><br><span class="line">    p = head.next</span><br><span class="line">    head.next=nil</span><br><span class="line">    for p != nil&#123;</span><br><span class="line">        temp = temp.next</span><br><span class="line">        temp.next = head</span><br><span class="line">        head = p</span><br><span class="line">        p = temp</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>c++</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line"></span><br><span class="line">    ListNode *next;</span><br><span class="line">    int val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* CreateListNode()&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* head =new ListNode;</span><br><span class="line">        p = head;</span><br><span class="line">        for (int i =0; i &lt;10; i++)&#123;</span><br><span class="line">            ListNode* node =new ListNode;</span><br><span class="line">            node -&gt; next =NULL;</span><br><span class="line">            node -&gt; val = i;</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            p = node;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* DeletedListNode(ListNode* head,int val)&#123;</span><br><span class="line">        if head == NULL&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p-&gt;next != NULL &amp;&amp; p-&gt;val != val)&#123;</span><br><span class="line">            temp = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p-&gt;val == val)&#123;</span><br><span class="line">            if (p == head)&#123;</span><br><span class="line">                head = p-&gt;next;</span><br><span class="line">                delete p;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                temp-&gt;next = p-&gt;next;</span><br><span class="line">                delete p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* InsertListNode(ListNode* head,int val)&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line"></span><br><span class="line">        ListNode* node = new ListNode;</span><br><span class="line">        node-&gt;val = val;</span><br><span class="line"></span><br><span class="line">        while(p-&gt;next != NULL &amp;&amp; p-&gt;val &lt; node-&gt;val)&#123;</span><br><span class="line">            temp = p;</span><br><span class="line">            p= p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;val &lt;= p-&gt;val)&#123;</span><br><span class="line">            if (p == head)&#123;//头部插入</span><br><span class="line">                head = node;</span><br><span class="line">                node -&gt; next = p;</span><br><span class="line">            &#125;else&#123;//中间插入</span><br><span class="line">                temp -&gt; next = node;</span><br><span class="line">                node -&gt; next = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;//链表尾部插入</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            node-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* ReverseListNode(ListNode* head)&#123;</span><br><span class="line">        if (head == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        head-&gt;next = NULL;</span><br><span class="line">        while(p!=NULL)&#123;</span><br><span class="line">            temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* DeleteListNode(ListNode* head,int val)&#123;</span><br><span class="line"></span><br><span class="line">        if (head == NULL) return NULL;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        if (p-&gt;val == val)&#123;</span><br><span class="line">            if (p == head)&#123;</span><br><span class="line">            head = p-&gt;next;</span><br><span class="line">            delete p;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp-&gt;next = p-&gt;next;</span><br><span class="line">                delete p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* InsertListNode(ListNode* head,int val)&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line"></span><br><span class="line">        ListNode* newNode = new ListNode;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line"></span><br><span class="line">        while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        if (p-&gt;val &lt;= newNode-&gt;val )&#123;</span><br><span class="line">            if(p == head)&#123;</span><br><span class="line">                head = newNode;</span><br><span class="line">                newNode-&gt;next = p; </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp-&gt;next = newNode;</span><br><span class="line">                newNode-&gt;next = p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;//尾部插入</span><br><span class="line">            p-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单链表的创建、插入、删除-倒置&quot;&gt;&lt;a href=&quot;#单链表的创建、插入、删除-倒置&quot; class=&quot;headerlink&quot; title=&quot;单链表的创建、插入、删除 倒置&quot;&gt;&lt;/a&gt;单链表的创建、插入、删除 倒置&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;go&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>http相关特性</title>
    <link href="http://yoursite.com/2018/10/25/http/"/>
    <id>http://yoursite.com/2018/10/25/http/</id>
    <published>2018-10-25T11:46:38.000Z</published>
    <updated>2018-11-24T06:31:08.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http通信的过程"><a href="#http通信的过程" class="headerlink" title="http通信的过程"></a>http通信的过程</h3><p>(1) 建立tcp链接<br>(2) web浏览器向web服务器发送请求命令<br>(3) web浏览器发送请求头消息<br>(4) web服务器应答<br>(5) web服务器发送应答头消息<br>(6) web服务器向浏览器发送数据<br>(7) web服务器关闭tcp链接  </p><h3 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h3><p>1.新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p>2.多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p>3.header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>4.服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</p><h3 id="http-url-字符含义"><a href="#http-url-字符含义" class="headerlink" title="http url 字符含义"></a>http url 字符含义</h3><ul><li><p>URL特殊符号及对应的十六进制值编码：  </p><p>  (1)’+’     URL中+号表示空格                  %2B  </p><p>  (2)空格     URL中的空格可以用+号或者编码        %20  </p><p>  (3)/       分隔目录和子目录                   %2F  </p><p>  (4)?       分隔实际的 URL 和参数              %3F  </p><p>  (5)%       指定特殊字符                      %25  </p><p>  (6)’#’       表示书签                       %23  </p><p>  (7)&amp;       URL中指定的参数间的分隔符           %26  </p><p>  (8)=       URL中指定参数的值                 %3D</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;http通信的过程&quot;&gt;&lt;a href=&quot;#http通信的过程&quot; class=&quot;headerlink&quot; title=&quot;http通信的过程&quot;&gt;&lt;/a&gt;http通信的过程&lt;/h3&gt;&lt;p&gt;(1) 建立tcp链接&lt;br&gt;(2) web浏览器向web服务器发送请求命令&lt;br&gt;
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2018/09/29/first-blog/"/>
    <id>http://yoursite.com/2018/09/29/first-blog/</id>
    <published>2018-09-29T11:15:34.000Z</published>
    <updated>2018-11-23T06:53:13.808Z</updated>
    
    <content type="html"><![CDATA[<ul><li>welcome to my first blog, to be continued 。。。。。。</li><li>hah</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;welcome to my first blog, to be continued 。。。。。。&lt;/li&gt;
&lt;li&gt;hah&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="Hello" scheme="http://yoursite.com/categories/Hello/"/>
    
    
  </entry>
  
</feed>
