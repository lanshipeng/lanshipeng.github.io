<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinker&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-03T03:47:43.207Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lan_shipeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka消息中间件</title>
    <link href="http://yoursite.com/2018/12/19/kafka/"/>
    <id>http://yoursite.com/2018/12/19/kafka/</id>
    <published>2018-12-19T14:06:13.515Z</published>
    <updated>2019-04-03T03:47:43.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cli-of-kafka"><a href="#cli-of-kafka" class="headerlink" title="cli of kafka"></a>cli of kafka</h2><ul><li><p>start zookeeper</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties</span><br></pre></td></tr></table></figure></li><li><p>start kafka</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start /usr/local/etc/kafka/server.properties</span><br></pre></td></tr></table></figure></li><li><p>create topic</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/kafka/2.1.0</span><br><span class="line">./bin/kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure></li><li><p>show topics</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/kafka/2.1.0</span><br><span class="line">./bin/kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure></li><li><p>delete topic</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/kafka/2.1.0</span><br><span class="line">./bin/kafka-run-class kafka.admin.DeleteTopicCommand --topic test --zookeeper127.0.0.1:2181</span><br></pre></td></tr></table></figure></li><li><p>start producer</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/kafka/2.1.0</span><br><span class="line">bin/kafka-console-producer --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure></li><li><p>start consumer</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    cd /usr/local/Cellar/kafka/2.1.0</span><br><span class="line">    ./bin/kafka-console-consumer --bootstrap-server localhost:9092 --group cousunmer --topic test --from-beginning</span><br><span class="line">    ``` </span><br><span class="line">- stop kafka</span><br></pre></td></tr></table></figure><p>  cd /usr/local/Cellar/kafka/2.1.0<br>   ./bin/kafka-server-stop</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 查看消费组</span><br><span class="line">    - 查看消费组列表</span><br></pre></td></tr></table></figure><pre><code>./bin/kafka-consumer-groups --bootstrap-server localhost:9092 --list<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 查看某个消费组信息</span><br></pre></td></tr></table></figure>/bin/kafka-consumer-groups --bootstrap-server localhost:9092  --describe --group consumer03<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 查看topic</span><br><span class="line">    - 查看topic列表</span><br></pre></td></tr></table></figure>./bin/kafka-topics.sh --zookeeper localhost:2181 --list<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 查看指定topic信息</span><br></pre></td></tr></table></figure>./bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic Hello-Kafka<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 修改topic分区数</span><br></pre></td></tr></table></figure>./bin/kafka-topics.sh --zookeeper localhost：2181 --alter --topic Hello-Kafka --partitions 3```</code></pre></li></ul><h2 id="why-need-kafka"><a href="#why-need-kafka" class="headerlink" title="why need kafka?"></a>why need kafka?</h2><ul><li>解藕消息的生产和消费</li><li>缓冲</li><li><p>并行</p></li><li><p>设计目标</p><ul><li>消息持久化：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上的数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐：在廉价的商用机器上也能支持单机每秒10万条以上的吞吐量。</li><li>分布式：支持消息分区以及分布式消费，并保证分区内的消息顺序。</li><li>跨平台：支持不同语言平台的客户端。</li><li>实时性：支持实时数据处理和离线数据处理。</li><li>伸缩性：支持水平扩展（producer可以将数据发给多个broker上的多个partition,consumer也可以从多个broker上的不同partition读取数据）</li></ul></li></ul><h2 id="使用场景1"><a href="#使用场景1" class="headerlink" title="使用场景1:"></a>使用场景1:</h2><ul><li>解藕 各个系统之间通过消息系统这个统一的接口交换数据，无须关心彼此的存在</li><li>冗余 消息系统具有持久化的能力，规避消息处理前丢失的风险</li><li>拓展 消息系统是统一的数据接口 各系统可独立扩展</li><li>异步通信 在不需要立即处理请求的情况下 可以将请求放入消息系统 合适的时候再处理</li><li>峰值处理能力 消息系统可以顶住峰值流量 业务系统可根据处理能力从消息系统获取并处理对应量的请求</li><li>可恢复性 系统中部分组件失效不影响整个系统 恢复后仍可从消息系统获取并处理数据</li></ul><h2 id="常用消息系统对比"><a href="#常用消息系统对比" class="headerlink" title="常用消息系统对比"></a>常用消息系统对比</h2><ul><li>RabbitMQ erlang编写 支持多协议AMQP，XMPP,SMTP,STOMP,支持负载均衡 数据持久化<br>  支持peer-2-peer和发布/订阅模式</li><li>Redis 轻量级。就入队操作而言 redis对于短消息小于10kb的性能比rabbitmq好</li><li>ZeroMQ 轻量级 不需要单独消息服务器或者中间件，应用程序扮演该角色，peer-2-peer本质是一个库</li><li>ActiveMQ JMS实现 peer-to-peer 支持持久化 XA分布式事务</li><li>kafka高性能跨语言的分布式发布/订阅消息系统 数据持久化 全分布式 同时支持在线和离线处理</li><li>MetaQ/RocketMQ 纯java实现 发布/订阅消息系统 支持本地事务和分布式事务</li></ul><h2 id="zookeeper-amp-kafka"><a href="#zookeeper-amp-kafka" class="headerlink" title="zookeeper &amp; kafka"></a>zookeeper &amp; kafka</h2><p>kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。而客户端会在zookeeper上注册相关的watcher。一旦zookeeper发生变化，客户端能及时感知并作出相应调整。</p><p>说明：Producer端使用zookeeper用来”发现”broker列表,以及和Topic下每个partition的leader建立socket连接并发送消息。也就是说每个Topic的partition是由Lead角色的Broker端使用zookeeper来注册broker信息,以及监测partition leader存活性.Consumer端使用zookeeper用来注册consumer信息,其中包括consumer消费的partition列表等,同时也用来发现broker列表,并和partition leader建立socket连接,并获取消息.</p><h2 id="消息传递pull-amp-push"><a href="#消息传递pull-amp-push" class="headerlink" title="消息传递pull &amp; push"></a>消息传递pull &amp; push</h2><ul><li><p>Producer和consumer采用的是push-and-pull模式<br>  Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的   </p></li><li><p>question: customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push?</p><ul><li>push   <ul><li>优势：<br>  延时低  </li><li>劣势：<br>  push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。当broker推送速率远高于消费者消费速率，consumer可能崩溃。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。</li></ul></li><li>pull(kafka选择的模式)  <ul><li>优势:<br>  而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</li><li>劣势:<br>  如果处理不好，实时性不足(kafka使用long polling)<br>  如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发送）  </li></ul></li></ul></li></ul><h2 id="Semantic"><a href="#Semantic" class="headerlink" title="Semantic"></a>Semantic</h2><ul><li><p>topic &amp; partition<br>  一个队列只有一种topic,一种topic的消息可以根据key值分散到多条队列中。</p><p>  topic在逻辑上可以被认为是一个在的queue，每条消费都必须指定它的topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以水平扩展，物理上把topic分成一个或多个partition（为了加快消费速度），每个partition在物理上对应一个文件夹，该文件夹下存储这个partition的所有消息和索引文件</p></li><li><p>broker<br>  消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</p></li><li><p>offset<br>  每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息</p></li><li><p>kafka 支持多个consumer group 消费一条消息。但是如果一个consumer group 下有多个consumer，那么只能有一个consumer消费该条消息。这种机制可实现消息的单播和广播（可通过启动多个consumer验证）。</p></li></ul><h2 id="publish-amp-subscribe"><a href="#publish-amp-subscribe" class="headerlink" title="publish &amp; subscribe"></a>publish &amp; subscribe</h2><ul><li><p>生产者(producer)生产消息(数据流), 将消息发送到到kafka指定的主题队列(topic)中，也可以发送到topic中的指定分区(partition)中，消费者(consumer)从kafka的指定队列中获取消息，然后来处理消息</p></li><li><p>相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息</p></li></ul><h2 id="delivery-guarantee："><a href="#delivery-guarantee：" class="headerlink" title="delivery guarantee："></a>delivery guarantee：</h2><ul><li>At most once 消息可能会丢，但绝不会重复传输<br>读完消息先commit再处理，如果消息在commit后还没来得及处理就crash了，下次重新开始工作后无法读到刚刚提交但未处理的消息。</li><li>At least one 消息绝不会丢，但可能会重复传输<br>先处理完再commit,如果消息在处理完但在commit之前crash了，下次重新开始工作后还会处理未commit的消息</li><li>Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的</li></ul><p>代码地址：<a href="https://github.com/lanshipeng/kafka-example" target="_blank" rel="noopener">https://github.com/lanshipeng/kafka-example</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cli-of-kafka&quot;&gt;&lt;a href=&quot;#cli-of-kafka&quot; class=&quot;headerlink&quot; title=&quot;cli of kafka&quot;&gt;&lt;/a&gt;cli of kafka&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;start zookeeper&lt;/p&gt;
 
      
    
    </summary>
    
      <category term="消息队列" scheme="http://yoursite.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>xargs</title>
    <link href="http://yoursite.com/2018/12/18/xargs/"/>
    <id>http://yoursite.com/2018/12/18/xargs/</id>
    <published>2018-12-18T08:13:34.935Z</published>
    <updated>2019-03-26T09:45:50.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><pre><code>命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数(默认情况下是通过空格分割) 然后将参数传递给其后面的命令，作为后面命令的命令行参数</code></pre><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><pre><code>xargs将其标准输入中的内容以空白(包括空格、Tab、回车换行等)分割成多个后当作命令行参数传给后面的命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;11@22@33&quot; |xargs -d &apos;@&apos; echo</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;xargs&quot;&gt;&lt;a href=&quot;#xargs&quot; class=&quot;headerlink&quot; title=&quot;xargs&quot;&gt;&lt;/a&gt;xargs&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数(默认情况下是通过空格分割) 然
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="xargs" scheme="http://yoursite.com/tags/xargs/"/>
    
  </entry>
  
  <entry>
    <title>curl参数</title>
    <link href="http://yoursite.com/2018/12/18/curl/"/>
    <id>http://yoursite.com/2018/12/18/curl/</id>
    <published>2018-12-18T02:47:34.054Z</published>
    <updated>2018-12-18T09:04:17.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="o-输出到文件"><a href="#o-输出到文件" class="headerlink" title="-o 输出到文件"></a>-o 输出到文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o home.html  http://www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="s-不输出任何东西"><a href="#s-不输出任何东西" class="headerlink" title="-s 不输出任何东西"></a>-s 不输出任何东西</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s</span><br></pre></td></tr></table></figure><h2 id="进度条显示当前传送状态"><a href="#进度条显示当前传送状态" class="headerlink" title="-# 进度条显示当前传送状态"></a>-# 进度条显示当前传送状态</h2><h2 id="O-后面的url要具体到某个文件，不然抓不下来"><a href="#O-后面的url要具体到某个文件，不然抓不下来" class="headerlink" title="-O 后面的url要具体到某个文件，不然抓不下来"></a>-O 后面的url要具体到某个文件，不然抓不下来</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O  http://www.baidu.com/1.jpg</span><br></pre></td></tr></table></figure><h2 id="x-使用http代理"><a href="#x-使用http代理" class="headerlink" title="-x 使用http代理"></a>-x 使用http代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x 24.10.28.84:32779 -o home.html http://www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="断点续传，-C-大写的"><a href="#断点续传，-C-大写的" class="headerlink" title="断点续传，-C(大写的)"></a>断点续传，-C(大写的)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -C -O  http://www.baidu.com/1.jpg</span><br></pre></td></tr></table></figure><h2 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用cookie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -b ./cookie.txt  http://www.baidu.com/admin</span><br></pre></td></tr></table></figure><h2 id="模拟表单信息，模拟登录，保存cookie信息"><a href="#模拟表单信息，模拟登录，保存cookie信息" class="headerlink" title="模拟表单信息，模拟登录，保存cookie信息"></a>模拟表单信息，模拟登录，保存cookie信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** http://blog.51yip.com/wp-login.php</span><br></pre></td></tr></table></figure><h2 id="模拟表单信息，模拟登录，保存头信息"><a href="#模拟表单信息，模拟登录，保存头信息" class="headerlink" title="模拟表单信息，模拟登录，保存头信息"></a>模拟表单信息，模拟登录，保存头信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -D ./cookie_c.txt -F log=aaaa -F pwd=****** http://blog.51yip.com/wp-login.php</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;o-输出到文件&quot;&gt;&lt;a href=&quot;#o-输出到文件&quot; class=&quot;headerlink&quot; title=&quot;-o 输出到文件&quot;&gt;&lt;/a&gt;-o 输出到文件&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>md转html</title>
    <link href="http://yoursite.com/2018/12/18/pandoc/"/>
    <id>http://yoursite.com/2018/12/18/pandoc/</id>
    <published>2018-12-18T02:43:16.991Z</published>
    <updated>2019-03-26T09:46:46.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="md-转html"><a href="#md-转html" class="headerlink" title="md 转html"></a>md 转html</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc -s -S --toc -c github2.css a.md  -o a.html</span><br></pre></td></tr></table></figure><h3 id="math-tex-转html"><a href="#math-tex-转html" class="headerlink" title="math.tex 转html"></a>math.tex 转html</h3><p> math.tex文件<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% Pandoc math demos</span><br><span class="line">$a^2 + b^2 = c^2$</span><br><span class="line">$v(t) = v_0 + \frac&#123;1&#125;&#123;2&#125;at^2$</span><br><span class="line">$\gamma = \frac&#123;1&#125;&#123;\sqrt&#123;1 - v^2/c^2&#125;&#125;$</span><br><span class="line">$\exists x \forall y (Rxy \equiv Ryx)$</span><br><span class="line">$p \wedge q \models p$</span><br><span class="line">$\Box\diamond p\equiv\diamond p$</span><br><span class="line">$\int_&#123;0&#125;^&#123;1&#125; x dx = \left[ \frac&#123;1&#125;&#123;2&#125;x^2 \right]_&#123;0&#125;^&#123;1&#125; = \frac&#123;1&#125;&#123;2&#125;$</span><br><span class="line">$e^x = \sum_&#123;n=0&#125;^\infty \frac&#123;x^n&#125;&#123;n!&#125; = \lim_&#123;n\rightarrow\infty&#125; (1+x/n)^n$</span><br></pre></td></tr></table></figure></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc math.tex -s --mathml  -o mathMathML.html</span><br></pre></td></tr></table></figure></code></pre><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><ul><li>-s –standalone转换输出文档时会自动加上合适的header和footer(例如standalone HTML, LaTeX, RTF)</li><li>-S </li><li>–toc </li><li>–data-dir=DIRECTORY指定用户数据目录，设定之后会在该目录下搜索pandoc数据文件。如果没有指定该选项，则会使用默认的用户数据目录:$HOME/.pandoc可通过pandoc –version命令查看</li><li>-c URL, –css=URL链接到CSS样式表。该选项能够使用多次来引入多个文件，所指定的文件能够以指定的顺序依次引入</li><li>-mathml 参数强制 Pandoc 将 LaTeX 中的数学公式转换成 MathML</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;md-转html&quot;&gt;&lt;a href=&quot;#md-转html&quot; class=&quot;headerlink&quot; title=&quot;md 转html&quot;&gt;&lt;/a&gt;md 转html&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="pandoc" scheme="http://yoursite.com/tags/pandoc/"/>
    
  </entry>
  
  <entry>
    <title>jq</title>
    <link href="http://yoursite.com/2018/12/18/jq/"/>
    <id>http://yoursite.com/2018/12/18/jq/</id>
    <published>2018-12-18T02:42:57.210Z</published>
    <updated>2018-12-18T09:23:44.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h3><pre><code>jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本</code></pre><h3 id="“-”"><a href="#“-”" class="headerlink" title="“.”"></a>“.”</h3><pre><code>最简单的jq程序是表达式&quot;.&quot;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat json.text|jq .</span><br></pre></td></tr></table></figure>example<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;tool&quot;,</span><br><span class="line">&quot;url&quot;: &quot;http://tool.china.com&quot;,</span><br><span class="line">&quot;addr&quot;: &#123;</span><br><span class="line">    &quot;city&quot;: &quot;beijing&quot;,</span><br><span class="line">    &quot;country&quot;: &quot;china&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;array&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;comp&quot;: &quot;google&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;http://www.google.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;comp&quot;: &quot;baidu&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;http://www.baidu.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat json.text|jq &apos;.[0]&apos;</span><br></pre></td></tr></table></figure></code></pre><h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat json.txt | jq &apos;.[0] | &#123;name:.name,city:.addr.city&#125;&apos;</span><br></pre></td></tr></table></figure>echo:{    &quot;name&quot;:&quot;jjj&quot;,    &quot;city&quot;:&quot;bj&quot;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat json.txt | jq &apos;.[0] | &#123;name:.array[0].comp,city:.addr.city&#125;&apos;</span><br></pre></td></tr></table></figure>echo:{    &quot;name&quot;:&quot;google&quot;,    &quot;city&quot;:&quot;bj&quot;}</code></pre><h3 id="把jq的输出当作一个数组"><a href="#把jq的输出当作一个数组" class="headerlink" title="[] 把jq的输出当作一个数组"></a>[] 把jq的输出当作一个数组</h3><h3 id="自定义key"><a href="#自定义key" class="headerlink" title="{} 自定义key"></a>{} 自定义key</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat json.txt | jq &apos;.[0] | &#123;username:.array[0].comp,livecity:.addr.city&#125;&apos;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jq&quot;&gt;&lt;a href=&quot;#jq&quot; class=&quot;headerlink&quot; title=&quot;jq&quot;&gt;&lt;/a&gt;jq&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本
&lt;/cod
      
    
    </summary>
    
      <category term="json文本处理" scheme="http://yoursite.com/categories/json%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>atomic原子操作</title>
    <link href="http://yoursite.com/2018/12/10/atomic/"/>
    <id>http://yoursite.com/2018/12/10/atomic/</id>
    <published>2018-12-10T06:33:02.604Z</published>
    <updated>2019-03-26T09:48:38.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="go的原子操作"><a href="#go的原子操作" class="headerlink" title="go的原子操作"></a>go的原子操作</h3><p>atomic 提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。</p><ul><li><p>atomic常见操作有：</p><ul><li><p>增减<br>  第一个参数必须是指针类型的值，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的CPU指令，确保同一时间只有一个goroutine能够进行操作。</p><ul><li><p>func AddInt32(addr *int32, delta int32) (new int32)</p></li><li><p>func AddInt64(addr *int64, delta int64) (new int64)</p></li><li><p>func AddUint32(addr *uint32, delta uint32) (new uint32)</p></li><li><p>func AddUint64(addr *uint64, delta uint64) (new uint64)</p></li><li><p>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m int64=0</span><br><span class="line">atomic.AddInt32(&amp;m,3)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>载入  </p><p>  载入操作能够保证原子的读变量的值，当读取的时候，任何其他CPU操作都无法对该变量进行读写，其实现机制受到底层硬件的支持。</p><ul><li><p>func LoadInt32(addr *int32) (val int32)</p></li><li><p>func LoadInt64(addr *int64) (val int64)</p></li><li><p>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</p></li><li><p>func LoadUint32(addr *uint32) (val uint32)</p></li><li><p>func LoadUint64(addr *uint64) (val uint64)</p></li><li><p>func LoadUintptr(addr *uintptr) (val uintptr)</p></li></ul></li><li><p>交换  </p><p>  相对于CAS，明显此类操作更为暴力直接，并不管变量的旧值是否被改变，直接赋予新值然后返回背替换的值。</p><ul><li><p>unc SwapInt32(addr *int32, new int32) (old int32)</p></li><li><p>func SwapInt64(addr *int64, new int64) (old int64)</p></li><li><p>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</p></li><li><p>func SwapUint32(addr *uint32, new uint32) (old uint32)</p></li><li><p>func SwapUint64(addr *uint64, new uint64) (old uint64)</p></li><li><p>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</p></li></ul></li><li><p>比较并交换<br>  该操作在进行交换前首先确保变量的值未被更改，即仍然保持参数 old 所记录的值，满足此前提下才进行交换操作。CAS的做法类似操作数据库时常见的乐观锁机制。</p><p>  需要注意的是，当有大量的goroutine 对变量进行读写操作时，可能导致CAS操作无法成功，这时可以利用for循环多次尝试。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var value int64</span><br><span class="line">func atomicAddOp(tmp int64) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        oldValue := value</span><br><span class="line">        if atomic.CompareAndSwapInt64(&amp;value, oldValue, oldValue+tmp) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</p></li><li><p>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</p></li><li><p>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</p></li><li><p>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</p></li><li><p>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</p></li><li><p>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</p></li></ul></li><li><p>存储<br>  此类操作确保了写变量的原子性，避免其他操作读到了修改变量过程中的脏数据。</p><ul><li><p>func StoreInt32(addr *int32, val int32)</p></li><li><p>func StoreInt64(addr *int64, val int64)</p></li><li><p>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</p></li><li><p>func StoreUint32(addr *uint32, val uint32)</p></li><li><p>func StoreUint64(addr *uint64, val uint64)</p></li><li><p>func StoreUintptr(addr *uintptr, val uintptr)</p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;go的原子操作&quot;&gt;&lt;a href=&quot;#go的原子操作&quot; class=&quot;headerlink&quot; title=&quot;go的原子操作&quot;&gt;&lt;/a&gt;go的原子操作&lt;/h3&gt;&lt;p&gt;atomic 提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atom
      
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="atomic" scheme="http://yoursite.com/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>memcached&#39;s note</title>
    <link href="http://yoursite.com/2018/11/11/memcached/"/>
    <id>http://yoursite.com/2018/11/11/memcached/</id>
    <published>2018-11-11T03:39:55.418Z</published>
    <updated>2018-12-27T08:39:41.649Z</updated>
    
    <content type="html"><![CDATA[<h4 id="save-cmd"><a href="#save-cmd" class="headerlink" title="save cmd"></a>save cmd</h4><ol><li><p>set key flags exptime bytes [noreply]<br>value  </p><p> 说明：<br> （如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。</p><p> [key]: key-value 中的key 用于查找缓存值<br> [flags]: 包括简直对的整型参数，客户机使用它存储关于简直对的额外信息<br> [exptime]: 在缓存中保存键值对的时间长度 （以s为单位）<br> [bytes]: 缓存中字节数<br> [noreply]: 告知服务器不需要返回数据<br> [value]: 存储的值(始终位于第二行)  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> out info:</p><p> – STORED：保存成功后输出。<br> – ERROR：在保存失败后输出。</p></li><li><p>add key flags exptime bytes [noreply]<br>value</p><p> 说明：<br> （如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add new_key 0 900 10</span><br><span class="line">data_value</span><br><span class="line">STORED</span><br><span class="line">get new_key</span><br><span class="line">VALUE new_key 0 10</span><br><span class="line">data_value</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> out info;</p><p> – STORED：保存成功后输出。<br> – NOT_STORED ：在保存失败后输出。</p></li><li><p>replace key flags exptime bytes [noreply]<br>value</p><p> 说明：<br> （如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add mykey 0 900 10</span><br><span class="line">data_value</span><br><span class="line">STORED</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 0 10</span><br><span class="line">data_value</span><br><span class="line">END</span><br><span class="line">replace mykey 0 900 16</span><br><span class="line">some_other_value</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 0 16</span><br><span class="line">some_other_value</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> out info:</p><p> – STORED：保存成功后输出。<br> – NOT_STORED：执行替换失败后输出。</p></li><li><p>append key flags exptime bytes [noreply]<br>value</p><p> 说明：<br> （Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据 。）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line">append runoob 0 900 5</span><br><span class="line">redis</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 14</span><br><span class="line">memcachedredis</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> out info:<br> – STORED：保存成功后输出。<br> – NOT_STORED：该键在 Memcached 上不存在。<br> – CLIENT_ERROR：执行错误。</p></li><li><p>prepend key flags exptime bytes [noreply]<br>value</p><p> 说明：<br> （<br> Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据 。）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line">prepend runoob 0 900 5</span><br><span class="line">redis</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 14</span><br><span class="line">redismemcached</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> out info:<br> – STORED：保存成功后输出。<br> – NOT_STORED：该键在 Memcached 上不存在。<br> – CLIENT_ERROR：执行错误。</p></li><li><p>cas key flags exptime bytes unique_cas_token [noreply] value </p></li></ol><pre><code>params:    unique_cas_token通过 gets 命令获取的一个唯一的64位值。out info:-- STORED：保存成功后输出。-- ERROR：保存出错或语法错误。-- EXISTS：在最后一次取值后另外一个用户也在更新该数据。-- NOT_FOUND：Memcached 服务上不存在该键值。</code></pre><ol start="7"><li><p>get key</p><p> 说明：<br> （<br> Memcached get 命令获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。）</p><p> 多个key使用空格隔开：</p><pre><code>get key1 key2 key3    </code></pre></li><li><p>gets key</p><p> 说明：<br> (Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">gets runoob</span><br><span class="line">VALUE runoob 0 9 1</span><br><span class="line">memcached</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p> 使用 gets 命令的输出结果中，在最后一列的数字 1 代表了 key 为 runoob 的 CAS 令牌    </p></li><li><p>delete key [noreply]  </p><p> 说明：<br> (删除已存在的key)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set runoob 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line">get runoob</span><br><span class="line">VALUE runoob 0 9</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line">delete runoob</span><br><span class="line">DELETED</span><br><span class="line">get runoob</span><br><span class="line">END</span><br><span class="line">delete runoob</span><br><span class="line">NOT_FOUND</span><br></pre></td></tr></table></figure><p> out info:<br> – DELETED：删除成功。<br> – ERROR：语法错误或删除失败。<br> – NOT_FOUND：key 不存在。      </p></li><li><p>incr key increment_value  </p><p>说明：<br>key：键值 key-value 结构中的 key，用于查找缓存值。<br>increment_value： 增加的数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set visitors 0 900 2</span><br><span class="line">10</span><br><span class="line">STORED</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 2</span><br><span class="line">10</span><br><span class="line">END</span><br><span class="line">incr visitors 5</span><br><span class="line">15</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 2</span><br><span class="line">15</span><br><span class="line">END</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set visitors 0 900 2</span><br><span class="line">10</span><br><span class="line">STORED</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 2</span><br><span class="line">10</span><br><span class="line">END</span><br><span class="line">decr visitors 5</span><br><span class="line">5</span><br><span class="line">get visitors</span><br><span class="line">VALUE visitors 0 1</span><br><span class="line">5</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>out info:<br>– NOT_FOUND：key 不存在。<br>– CLIENT_ERROR：自增值不是对象。<br>– ERROR其他错误，如语法错误等。  </p></li></ol><h4 id="count-cmd"><a href="#count-cmd" class="headerlink" title="count cmd"></a>count cmd</h4><ol start="11"><li><p>stats  </p><p>Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。</p></li></ol><ol start="12"><li><p>stats items  </p><p>Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。</p></li><li><p>stats sizes </p><p>Memcached stats sizes 命令用于显示所有item的大小和个数。</p><p>该信息返回两列，第一列是 item 的大小，第二列是 item 的个数。</p></li><li><p>stats slabs</p><p>Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。</p></li><li><p>flush_all  </p><p>Memcached flush_all 命令用于清理缓存中的所有 key=&gt;value(键=&gt;值) 对。<br>该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;save-cmd&quot;&gt;&lt;a href=&quot;#save-cmd&quot; class=&quot;headerlink&quot; title=&quot;save cmd&quot;&gt;&lt;/a&gt;save cmd&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;set key flags exptime bytes [noreply]
      
    
    </summary>
    
      <category term="缓存" scheme="http://yoursite.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="memcached" scheme="http://yoursite.com/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库使用规范总结</title>
    <link href="http://yoursite.com/2018/10/26/sql/"/>
    <id>http://yoursite.com/2018/10/26/sql/</id>
    <published>2018-10-26T02:12:44.000Z</published>
    <updated>2018-12-21T03:50:10.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ul><li>表存储引擎设置为innodb</li><li>表字符集默认使用utf8,必要时使用utf8mb4。utf8mb4是utf8的超集,有存储4字节例如表情符号时使用他。</li><li><p>禁止数据库中存储大文件,例如照片.可以将大文件存储在对象存储系统中。数据库存储路径</p></li><li><p>一般不使用存储过程、视图、触发器,event.对数据库性能影响大，调试，排错，迁移都比较困难.拓展性差</p></li><li>对于互联网业务，能让站点层和服务层干的事,不要交到数据库</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>库名，表名,列名都必须小写,采用下划线分割</li><li>库名，表名,列名最好见名知意。长度不超过32个字符</li><li>库备份以bak为前缀，日期为后缀</li><li>从库以-s为后缀</li><li>备库以-ss为后缀</li></ul><h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><ul><li>单实例表个数控制在2000个以内</li><li>单表分表个数控制在1024个以内</li><li><p>表必须有主键，一般使用unsigned整数类型为主键  </p></li><li><p>删除无主键的表,如果是row模式的主从架构。从库会挂住</p></li><li><p>一般不使用外键,如果要保证完整性。应该由应用程式实现  </p></li><li><p>外键使得表之间相互耦合，影响update/delete性能.有可能造成死锁</p></li><li>建议将大字段,访问频率少的字段拆分到单独表中存储，分离冷热数据  </li></ul><h3 id="列设计规范"><a href="#列设计规范" class="headerlink" title="列设计规范"></a>列设计规范</h3><ul><li>根据业务区分使用tinyint/int/bigint,分别占用1/4/8字节</li><li><p>根据业务区分使用char/varchar</p></li><li><p>字段长度固定,或者长度近似的业务场景,适用char,能减少碎片,查询性能高</p></li><li>字段长度相差大，或者更新少的业务场景，适合使用varchar,可以减少空间</li><li><p>根据业务区分使用datetime/timestamp(分别占5/4字节)</p></li><li><p>把not null字段设置为默认值.因为null的列使用索引统计,值都更加复杂。更难优化。只能使用is null 或者is not null 而在=/!=/in/not in有大坑</p></li><li><p>使用int unsigned 存储ipv4 ,不要用char(15).</p></li><li>使用varchar(20)存储手机号,不要用整数</li><li>varchar可以模糊查询</li></ul><h3 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h3><ul><li>唯一索引使用uniq_[字段名]来命名</li><li>非唯一索引使用idx_[字段名]来命名</li><li><p>单张表索引数量控制在5个以内</p></li><li><p>太多索引影响写性能;生成执行计划时,如果索引太多,会降低性能.并可能导致mysql选择不到最优索引</p></li><li>组合索引字段数建议不超过5个</li><li>不建议在频繁更新的字段上建立索引</li><li>非必要不用join查询，如果要join查询,被join的字段必须类型相同,并建立索引</li><li>组合索引最前缀原则,避免重复建索引,如果建立了(a,b,c)相当于建立了(a),(a,b),(a,b,c)</li></ul><h3 id="sql书写规范"><a href="#sql书写规范" class="headerlink" title="sql书写规范"></a>sql书写规范</h3><ul><li>尽量不写select *，只获取必要字段.否则会增加cpu/io/内存/带宽的消耗</li><li>同一个字段上的or改写成in,in的值要少于50个</li><li>应用程序捕获sql异常，方便定位线上问题         </li><li>insert必须指定字段,禁止使用insert into table values()</li><li>尽量不对大表join和子查询</li></ul><h3 id="建表实例"><a href="#建表实例" class="headerlink" title="建表实例"></a>建表实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">`user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;会员信息表主键，自增长&apos;,</span><br><span class="line">`uuid` bigint(20) DEFAULT &apos;0&apos; COMMENT &apos;会员唯一标识表主键，自增长&apos;,</span><br><span class="line">`guid` bigint(20) DEFAULT &apos;0&apos; COMMENT &apos;用户中心全局ID&apos;,</span><br><span class="line">`is_certed` tinyint(4) DEFAULT &apos;2&apos; COMMENT &apos;是否认证，1 认证 2  未认证&apos;,</span><br><span class="line">`mobile` varchar(40) COLLATE utf8mb4_bin NOT NULL COMMENT &apos;手机号码&apos;,</span><br><span class="line">`last_login_tm` datetime(6) DEFAULT &apos;0000-00-00 00:00:00.000000&apos; COMMENT &apos;最后一次登录时间&apos;,</span><br><span class="line">`last_login_device` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL COMMENT &apos;最后一次登录设备号&apos;,</span><br><span class="line">`remark` varchar(250) COLLATE utf8mb4_bin DEFAULT &apos;&apos; COMMENT &apos;备注&apos;,</span><br><span class="line">`is_deleted` tinyint(4) DEFAULT &apos;1&apos; COMMENT &apos;是否删除，1 未删除，2 已删除&apos;,</span><br><span class="line">`created_tm` datetime(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT &apos;创建时间，默认是 CURRENT_TIMESTAMP(6)&apos;,</span><br><span class="line">`updated_tm` datetime(6) DEFAULT &apos;0000-00-00 00:00:00.000000&apos; ON UPDATE CURRENT_TIMESTAMP(6) COMMENT &apos;修改时间，修改时 CURRENT_TIMESTAMP(6)&apos;,</span><br><span class="line">PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT=&apos;会员信息表&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;表存储引擎设置为innodb&lt;/li&gt;
&lt;li&gt;表字符集默认使用utf8,必要时使用utf8mb4。utf8mb
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库规范" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2018/10/25/sort/"/>
    <id>http://yoursite.com/2018/10/25/sort/</id>
    <published>2018-10-25T12:13:26.000Z</published>
    <updated>2018-10-25T12:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="golang-实现归并和堆排序"><a href="#golang-实现归并和堆排序" class="headerlink" title="golang 实现归并和堆排序"></a>golang 实现归并和堆排序</h4><p>1.归并排序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    a := make([]int,0,0)</span><br><span class="line">    r := make([]int,0,0)</span><br><span class="line">    a = []int&#123;4,1,3,2,6,5,7&#125;</span><br><span class="line">    r = []int&#123;0,0,0,0,0,0,0&#125;</span><br><span class="line">    mergesort(a,0,6,r)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">func Swap(a *int,b *int)&#123;</span><br><span class="line">    temp := *a</span><br><span class="line">    *a = *b</span><br><span class="line">    *b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func mergesort(a []int,start,end int64,result []int)&#123;</span><br><span class="line"></span><br><span class="line">    if end - start == 0&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if end - start == 1&#123;</span><br><span class="line">        if a[start] &gt; a[end]&#123;</span><br><span class="line">            Swap(&amp;a[start],&amp;a[end])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mergesort(a,start,(end-start+1)/2 + start,result)</span><br><span class="line">        mergesort(a,(end-start+1)/2 +1 + start,end,result)</span><br><span class="line">        merge(a,start,end,result)</span><br><span class="line">        var i int64 =0</span><br><span class="line">        for i=start;i&lt;=end;i++&#123;</span><br><span class="line">            a[i] = result[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func merge(a []int,start,end int64,result []int)&#123;</span><br><span class="line"></span><br><span class="line">    left_index  := start</span><br><span class="line">    left_length := (end-start+1)/2 +1</span><br><span class="line">    right_index := start + left_length</span><br><span class="line">    result_index := start</span><br><span class="line"></span><br><span class="line">    for  left_index &lt; start + left_length &amp;&amp; right_index &lt; end+1 &#123;</span><br><span class="line"></span><br><span class="line">        if a[left_index] &lt;= a[right_index]&#123;</span><br><span class="line">            result[result_index] = a[left_index]</span><br><span class="line">            result_index++</span><br><span class="line">            left_index++</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result[result_index] = a[right_index]</span><br><span class="line">            right_index++</span><br><span class="line">            result_index++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    for left_index &lt; start +left_length&#123;</span><br><span class="line">        result[result_index] = a[left_index]</span><br><span class="line">        result_index++</span><br><span class="line">        left_index++</span><br><span class="line">    &#125;</span><br><span class="line">    for right_index &lt; end+1&#123;</span><br><span class="line">        result[result_index] = a[right_index]</span><br><span class="line">        right_index++</span><br><span class="line">        result_index++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.堆排序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    a := make([]int,0,0)</span><br><span class="line">    a = []int&#123;1,4,2,3,7,9,8&#125;</span><br><span class="line">    heapsort(a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(a *int,b *int)&#123;</span><br><span class="line">    temp := *a</span><br><span class="line">    *a = *b</span><br><span class="line">    *b = temp</span><br><span class="line">&#125;</span><br><span class="line">func heapsort(a []int)&#123;</span><br><span class="line"></span><br><span class="line">    //创建大顶堆</span><br><span class="line">    var i int = 0</span><br><span class="line">    var j int = 0</span><br><span class="line">    for i= len(a)/2;i&gt;=0;i--&#123;</span><br><span class="line">        heapadjust(a,i,len(a))</span><br><span class="line">    &#125;</span><br><span class="line">    for j= len(a) -1 ;j&gt;=1;j--&#123;</span><br><span class="line">        swap(&amp;a[0],&amp;a[j])</span><br><span class="line">        heapadjust(a,0,j)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func heapadjust(a []int,i,length int)&#123;</span><br><span class="line"></span><br><span class="line">    var left int = 2*i +1</span><br><span class="line">    if left &lt; length&#123;</span><br><span class="line">        maxIndex := left</span><br><span class="line">        right := left + 1</span><br><span class="line">        if a[right] &gt; a[left] &amp;&amp; right &lt; length&#123;</span><br><span class="line">            maxIndex = right</span><br><span class="line">        &#125;</span><br><span class="line">        if a[maxIndex] &gt; a[i]&#123;</span><br><span class="line">            swap(&amp;a[maxIndex],&amp;a[i])</span><br><span class="line">            heapadjust(a,maxIndex,length)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;golang-实现归并和堆排序&quot;&gt;&lt;a href=&quot;#golang-实现归并和堆排序&quot; class=&quot;headerlink&quot; title=&quot;golang 实现归并和堆排序&quot;&gt;&lt;/a&gt;golang 实现归并和堆排序&lt;/h4&gt;&lt;p&gt;1.归并排序  &lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="http://yoursite.com/2018/10/25/list/"/>
    <id>http://yoursite.com/2018/10/25/list/</id>
    <published>2018-10-25T12:06:46.000Z</published>
    <updated>2019-03-26T09:05:12.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单链表的创建、插入、删除-倒置"><a href="#单链表的创建、插入、删除-倒置" class="headerlink" title="单链表的创建、插入、删除 倒置"></a>单链表的创建、插入、删除 倒置</h4><ul><li>go</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">type ListNode struct&#123;</span><br><span class="line">    value int</span><br><span class="line">    next *ListNode</span><br><span class="line">&#125;</span><br><span class="line">//创建单链表</span><br><span class="line">func (this *ListNode)CreateList()*ListNode&#123;</span><br><span class="line">    </span><br><span class="line">    head := new(ListNode)</span><br><span class="line">    ptail := new(ListNode)</span><br><span class="line">    ptail = head</span><br><span class="line">    for i :=0; i &lt;= 10; i++&#123;</span><br><span class="line">         xNode := new(ListNode)     </span><br><span class="line">         xNode.value = i</span><br><span class="line">         xNode.next = nil </span><br><span class="line">         ptail.next = xNode</span><br><span class="line">         ptail = xNode</span><br><span class="line">    &#125;</span><br><span class="line">    head = head.next</span><br><span class="line">    ptail.next = nil</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br><span class="line">//删除节点</span><br><span class="line">func (this *ListNode)DeleteListNod(head* ListNode,val int)&#123;  </span><br><span class="line">    if head == nil&#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp := new(ListNode)</span><br><span class="line">    p := new(ListNode)</span><br><span class="line">    p = head</span><br><span class="line">    for p.next != nil &amp;&amp; p.value != val&#123;</span><br><span class="line">        temp = p</span><br><span class="line">        p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">    if p.value == val&#123;</span><br><span class="line">        if p == head&#123;</span><br><span class="line">            head = temp.next</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp.next = p.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br><span class="line">//插入节点</span><br><span class="line">func (this *ListNode)InsertNode(head* ListNode,val int)*ListNode&#123;</span><br><span class="line">    if head == nil&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    xNode := new(ListNode)</span><br><span class="line">    xNode.value = val</span><br><span class="line">    xNode.next = nil</span><br><span class="line"></span><br><span class="line">    temp := new(ListNode)</span><br><span class="line">    p := new(ListNode)</span><br><span class="line">    p = head</span><br><span class="line">    for p.next != nil &amp;&amp; p.value &lt; val&#123;</span><br><span class="line">        temp = p</span><br><span class="line">        p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">    if p.value &lt;= val&#123;</span><br><span class="line">        if p == head&#123;</span><br><span class="line">            head = xNode</span><br><span class="line">            xNode.next = p</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp.next = xNode</span><br><span class="line">            xNode.next = p</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        p.next = xNode</span><br><span class="line">        xNode.next = nil</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br><span class="line">//链表倒置</span><br><span class="line">func (this *ListNode)Reverse(head* ListNode)*ListNode&#123;</span><br><span class="line">    if head==nil&#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    temp := new(ListNode)</span><br><span class="line">    p := new(ListNode)</span><br><span class="line">    p = head.next</span><br><span class="line">    head.next=nil</span><br><span class="line">    for p != nil&#123;</span><br><span class="line">        temp = temp.next</span><br><span class="line">        temp.next = head</span><br><span class="line">        head = p</span><br><span class="line">        p = temp</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>c++</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line"></span><br><span class="line">    ListNode *next;</span><br><span class="line">    int val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* CreateListNode()&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* head =new ListNode;</span><br><span class="line">        p = head;</span><br><span class="line">        for (int i =0; i &lt;10; i++)&#123;</span><br><span class="line">            ListNode* node =new ListNode;</span><br><span class="line">            node -&gt; next =NULL;</span><br><span class="line">            node -&gt; val = i;</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            p = node;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* DeletedListNode(ListNode* head,int val)&#123;</span><br><span class="line">        if head == NULL&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p-&gt;next != NULL &amp;&amp; p-&gt;val != val)&#123;</span><br><span class="line">            temp = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p-&gt;val == val)&#123;</span><br><span class="line">            if (p == head)&#123;</span><br><span class="line">                head = p-&gt;next;</span><br><span class="line">                delete p;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                temp-&gt;next = p-&gt;next;</span><br><span class="line">                delete p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* InsertListNode(ListNode* head,int val)&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line"></span><br><span class="line">        ListNode* node = new ListNode;</span><br><span class="line">        node-&gt;val = val;</span><br><span class="line"></span><br><span class="line">        while(p-&gt;next != NULL &amp;&amp; p-&gt;val &lt; node-&gt;val)&#123;</span><br><span class="line">            temp = p;</span><br><span class="line">            p= p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;val &lt;= p-&gt;val)&#123;</span><br><span class="line">            if (p == head)&#123;//头部插入</span><br><span class="line">                head = node;</span><br><span class="line">                node -&gt; next = p;</span><br><span class="line">            &#125;else&#123;//中间插入</span><br><span class="line">                temp -&gt; next = node;</span><br><span class="line">                node -&gt; next = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;//链表尾部插入</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            node-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* ReverseListNode(ListNode* head)&#123;</span><br><span class="line">        if (head == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        head-&gt;next = NULL;</span><br><span class="line">        while(p!=NULL)&#123;</span><br><span class="line">            temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* DeleteListNode(ListNode* head,int val)&#123;</span><br><span class="line"></span><br><span class="line">        if (head == NULL) return NULL;</span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        if (p-&gt;val == val)&#123;</span><br><span class="line">            if (p == head)&#123;</span><br><span class="line">            head = p-&gt;next;</span><br><span class="line">            delete p;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp-&gt;next = p-&gt;next;</span><br><span class="line">                delete p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* InsertListNode(ListNode* head,int val)&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* temp = NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line"></span><br><span class="line">        ListNode* newNode = new ListNode;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line"></span><br><span class="line">        while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        if (p-&gt;val &lt;= newNode-&gt;val )&#123;</span><br><span class="line">            if(p == head)&#123;</span><br><span class="line">                head = newNode;</span><br><span class="line">                newNode-&gt;next = p; </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp-&gt;next = newNode;</span><br><span class="line">                newNode-&gt;next = p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;//尾部插入</span><br><span class="line">            p-&gt;next = newNode;</span><br><span class="line">            newNode-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单链表的创建、插入、删除-倒置&quot;&gt;&lt;a href=&quot;#单链表的创建、插入、删除-倒置&quot; class=&quot;headerlink&quot; title=&quot;单链表的创建、插入、删除 倒置&quot;&gt;&lt;/a&gt;单链表的创建、插入、删除 倒置&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;go&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>http相关特性</title>
    <link href="http://yoursite.com/2018/10/25/http/"/>
    <id>http://yoursite.com/2018/10/25/http/</id>
    <published>2018-10-25T11:46:38.000Z</published>
    <updated>2018-12-21T10:06:33.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http通信的过程"><a href="#http通信的过程" class="headerlink" title="http通信的过程"></a>http通信的过程</h3><p>(1) 建立tcp链接<br>(2) web浏览器向web服务器发送请求命令<br>(3) web浏览器发送请求头消息<br>(4) web服务器应答<br>(5) web服务器发送应答头消息<br>(6) web服务器向浏览器发送数据<br>(7) web服务器关闭tcp链接  </p><h3 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h3><p>1.新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p>2.多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p>3.header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>4.服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</p><h3 id="http-url-字符含义"><a href="#http-url-字符含义" class="headerlink" title="http url 字符含义"></a>http url 字符含义</h3><ul><li><p>URL特殊符号及对应的十六进制值编码：  </p><p>  (1)’+’     URL中+号表示空格                  %2B  </p><p>  (2)空格     URL中的空格可以用+号或者编码        %20  </p><p>  (3)/       分隔目录和子目录                   %2F  </p><p>  (4)?       分隔实际的 URL 和参数              %3F  </p><p>  (5)%       指定特殊字符                      %25  </p><p>  (6)’#’       表示书签                       %23  </p><p>  (7)&amp;       URL中指定的参数间的分隔符           %26  </p><p>  (8)=       URL中指定参数的值                 %3D</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;http通信的过程&quot;&gt;&lt;a href=&quot;#http通信的过程&quot; class=&quot;headerlink&quot; title=&quot;http通信的过程&quot;&gt;&lt;/a&gt;http通信的过程&lt;/h3&gt;&lt;p&gt;(1) 建立tcp链接&lt;br&gt;(2) web浏览器向web服务器发送请求命令&lt;br&gt;
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2018/09/29/first-blog/"/>
    <id>http://yoursite.com/2018/09/29/first-blog/</id>
    <published>2018-09-29T11:15:34.000Z</published>
    <updated>2019-03-26T09:47:37.291Z</updated>
    
    <content type="html"><![CDATA[<ul><li>welcome to my first blog, to be continued 。。。。。。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;welcome to my first blog, to be continued 。。。。。。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="Hello" scheme="http://yoursite.com/categories/Hello/"/>
    
    
  </entry>
  
</feed>
