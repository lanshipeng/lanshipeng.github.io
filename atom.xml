<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinker&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-25T11:54:36.730Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lan_shipeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql数据库使用规范总结</title>
    <link href="http://yoursite.com/2018/10/25/sql/"/>
    <id>http://yoursite.com/2018/10/25/sql/</id>
    <published>2018-10-25T08:40:40.987Z</published>
    <updated>2018-10-25T11:54:36.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><ul><li>表存储引擎设置为innodb</li><li>表字符集默认使用utf8,必要时使用utf8mb4。utf8mb4是utf8的超集,有存储4字节例如表情符号时使用他。</li><li><p>禁止数据库中存储大文件,例如照片.可以将大文件存储在对象存储系统中。数据库存储路径</p></li><li><p>一般不使用存储过程、视图、触发器,event.对数据库性能影响大，调试，排错，迁移都比较困难.拓展性差</p></li><li>对于互联网业务，能让站点层和服务层干的事,不要交到数据库</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>库名，表名,列名都必须小写,采用下划线分割</li><li>库名，表名,列名最好见名知意。长度不超过32个字符</li><li>库备份以bak为前缀，日期为后缀</li><li>从库以-s为后缀</li><li>备库以-ss为后缀</li></ul><h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><ul><li>单实例表个数控制在2000个以内</li><li>单表分表个数控制在1024个以内</li><li><p>表必须有主键，一般使用unsigned整数类型为主键  </p><ul><li>删除无主键的表,如果是row模式的主从架构。从库会挂住</li></ul></li><li><p>一般不使用外键,如果要保证完整性。应该由应用程式实现  </p><ul><li>外键使得表之间相互耦合，影响update/delete性能.有可能造成死锁</li></ul></li><li>建议将大字段,访问频率少的字段拆分到单独表中存储，分离冷热数据  </li></ul><h3 id="列设计规范"><a href="#列设计规范" class="headerlink" title="列设计规范"></a>列设计规范</h3><ul><li>根据业务区分使用tinyint/int/bigint,分别占用1/4/8字节</li><li><p>根据业务区分使用char/varchar</p><ul><li>字段长度固定,或者长度近似的业务场景,适用char,能减少碎片,查询性能高</li><li>字段长度相差大，或者更新少的业务场景，适合使用varchar,可以减少空间</li></ul></li><li><p>根据业务区分使用datetime/timestamp(分别占5/4字节)</p></li><li><p>把not null字段设置为默认值.因为null的列使用索引统计,值都更加复杂。更难优化。只能使用is null 或者is not null 而在=/!=/in/not in有大坑</p></li><li><p>使用int unsigned 存储ipv4 ,不要用char(15).</p></li><li>使用varchar(20)存储手机号,不要用整数</li><li>varchar可以模糊查询</li></ul><h3 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h3><ul><li>唯一索引使用uniq_[字段名]来命名</li><li>非唯一索引使用idx_[字段名]来命名</li><li><p>单张表索引数量控制在5个以内</p><ul><li>太多索引影响写性能;生成执行计划时,如果索引太多,会降低性能.并可能导致mysql选择不到最优索引</li></ul></li><li>组合索引字段数建议不超过5个</li><li>不建议在频繁更新的字段上建立索引</li><li>非必要不用join查询，如果要join查询,被join的字段必须类型相同,并建立索引</li><li>组合索引最前缀原则,避免重复建索引,如果建立了(a,b,c)相当于建立了(a),(a,b),(a,b,c)</li></ul><h3 id="sql书写规范"><a href="#sql书写规范" class="headerlink" title="sql书写规范"></a>sql书写规范</h3><ul><li>尽量不写select *，只获取必要字段.否则会增加cpu/io/内存/带宽的消耗</li><li>同一个字段上的or改写成in,in的值要少于50个</li><li>应用程序捕获sql异常，方便定位线上问题         </li><li>insert必须指定字段,禁止使用insert into table values()</li><li>尽量不对大表join和子查询</li></ul><h3 id="建表实例"><a href="#建表实例" class="headerlink" title="建表实例"></a>建表实例</h3><p><br><br><br>    CREATE TABLE <code>user</code> (<br>    <code>user_id</code> bigint(20) NOT NULL AUTO_INCREMENT COMMENT ‘会员信息表主键，自增长’,<br>    <code>uuid</code> bigint(20) DEFAULT ‘0’ COMMENT ‘会员唯一标识表主键，自增长’,<br>    <code>guid</code> bigint(20) DEFAULT ‘0’ COMMENT ‘用户中心全局ID’,<br>    <code>is_certed</code> tinyint(4) DEFAULT ‘2’ COMMENT ‘是否认证，1 认证 2  未认证’,<br>    <code>mobile</code> varchar(40) COLLATE utf8mb4_bin NOT NULL COMMENT ‘手机号码’,<br>    <code>last_login_tm</code> datetime(6) DEFAULT ‘0000-00-00 00:00:00.000000’ COMMENT ‘最后一次登录时间’,<br>    <code>last_login_device</code> varchar(20) COLLATE utf8mb4_bin DEFAULT NULL COMMENT ‘最后一次登录设备号’,<br>    <code>remark</code> varchar(250) COLLATE utf8mb4_bin DEFAULT ‘’ COMMENT ‘备注’,<br>    <code>is_deleted</code> tinyint(4) DEFAULT ‘1’ COMMENT ‘是否删除，1 未删除，2 已删除’,<br>    <code>created_tm</code> datetime(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT ‘创建时间，默认是 CURRENT_TIMESTAMP(6)’,<br>    <code>updated_tm</code> datetime(6) DEFAULT ‘0000-00-00 00:00:00.000000’ ON UPDATE CURRENT_TIMESTAMP(6) COMMENT ‘修改时间，修改时 CURRENT_TIMESTAMP(6)’,<br>    PRIMARY KEY (<code>user_id</code>)<br>    ) ENGINE=InnoDB AUTO_INCREMENT=241157 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT=’会员信息表’;<br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;表存储引擎设置为innodb&lt;/li&gt;
&lt;li&gt;表字符集默认使用utf8,必要时使用utf8mb4。utf8mb
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库规范" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2018/10/25/sort/"/>
    <id>http://yoursite.com/2018/10/25/sort/</id>
    <published>2018-10-25T07:10:22.531Z</published>
    <updated>2018-10-25T11:57:21.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="golang-实现归并和堆排序"><a href="#golang-实现归并和堆排序" class="headerlink" title="golang 实现归并和堆排序"></a>golang 实现归并和堆排序</h4><p>1.归并排序  </p><p><br><br>    package main<br><br>    import “fmt”<br><br>    func main(){<br>        a := make([]int,0,0)<br>        r := make([]int,0,0)<br>        a = []int{4,1,3,2,6,5,7}<br>        r = []int{0,0,0,0,0,0,0}<br>        mergesort(a,0,6,r)<br>        fmt.Println(a)<br>        fmt.Println(r)<br>    }<br>    func Swap(a <em>int,b </em>int){<br>        temp := <em>a        </em>a = <em>b        </em>b = temp<br>    }<br><br>    func mergesort(a []int,start,end int64,result []int){<br><br>        if end - start == 0{<br>            return<br>        }<br>        if end - start == 1{<br>            if a[start] &gt; a[end]{<br>                Swap(&amp;a[start],&amp;a[end])<br>            }<br>        }else{<br>            mergesort(a,start,(end-start+1)/2 + start,result)<br>            mergesort(a,(end-start+1)/2 +1 + start,end,result)<br>            merge(a,start,end,result)<br>            var i int64 =0<br>            for i=start;i&lt;=end;i++{<br>                a[i] = result[i]<br>            }<br>        }<br><br>    }<br><br><br>    func merge(a []int,start,end int64,result []int){<br><br>        left_index  := start<br>        left_length := (end-start+1)/2 +1<br>        right_index := start + left_length<br>        result_index := start<br><br>        for  left_index &lt; start + left_length &amp;&amp; right_index &lt; end+1 {<br><br>            if a[left_index] &lt;= a[right_index]{<br>                result[result_index] = a[left_index]<br>                result_index++<br>                left_index++<br>            }else{<br>                result[result_index] = a[right_index]<br>                right_index++<br>                result_index++<br>            }<br><br>        }<br>        for left_index &lt; start +left_length{<br>            result[result_index] = a[left_index]<br>            result_index++<br>            left_index++<br>        }<br>        for right_index &lt; end+1{<br>            result[result_index] = a[right_index]<br>            right_index++<br>            result_index++<br>        }<br><br>    }<br></p><p>2.堆排序  </p><p><br><br>    package main<br><br>    import “fmt”<br><br>    func main(){<br>        a := make([]int,0,0)<br>        a = []int{1,4,2,3,7,9,8}<br>        heapsort(a)<br>        fmt.Println(a)<br>    }<br><br>    func swap(a <em>int,b </em>int){<br>        temp := <em>a        </em>a = <em>b        </em>b = temp<br>    }<br>    func heapsort(a []int){<br><br>        //创建大顶堆<br>        var i int = 0<br>        var j int = 0<br>        for i= len(a)/2;i&gt;=0;i–{<br>            heapadjust(a,i,len(a))<br>        }<br>        for j= len(a) -1 ;j&gt;=1;j–{<br>            swap(&amp;a[0],&amp;a[j])<br>            heapadjust(a,0,j)<br>        }<br><br>    }<br>    func heapadjust(a []int,i,length int){<br><br>        var left int = 2*i +1<br>        if left &lt; length{<br>            maxIndex := left<br>            right := left + 1<br>            if a[right] &gt; a[left] &amp;&amp; right &lt; length{<br>                maxIndex = right<br>            }<br>            if a[maxIndex] &gt; a[i]{<br>                swap(&amp;a[maxIndex],&amp;a[i])<br>                heapadjust(a,maxIndex,length)<br>            }<br>        }<br>    }<br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;golang-实现归并和堆排序&quot;&gt;&lt;a href=&quot;#golang-实现归并和堆排序&quot; class=&quot;headerlink&quot; title=&quot;golang 实现归并和堆排序&quot;&gt;&lt;/a&gt;golang 实现归并和堆排序&lt;/h4&gt;&lt;p&gt;1.归并排序  &lt;/p&gt;
&lt;p&gt;&lt;b
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="http://yoursite.com/2018/10/23/list/"/>
    <id>http://yoursite.com/2018/10/23/list/</id>
    <published>2018-10-23T10:22:15.819Z</published>
    <updated>2018-10-25T11:56:27.008Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单链表的创建、插入、删除-倒置"><a href="#单链表的创建、插入、删除-倒置" class="headerlink" title="单链表的创建、插入、删除 倒置"></a>单链表的创建、插入、删除 倒置</h4><ul><li><p>go</p><p>  </p><p>  type ListNode struct{</p><pre><code>value intnext *ListNode</code></pre><p>  }<br>  //创建单链表<br>  func (this <em>ListNode)CreateList()</em>ListNode{</p><pre><code>head := new(ListNode)ptail := new(ListNode)ptail = headfor i :=0; i &lt;= 10; i++{     xNode := new(ListNode)          xNode.value = i     xNode.next = nil      ptail.next = xNode     ptail = xNode}return phead</code></pre><p>  }<br>  //删除节点<br>  func (this <em>ListNode)DeleteListNod(head</em> ListNode,val int){  </p><pre><code>if head == nil{    return nil}temp := new(ListNode)p := new(ListNode)p = headfor p.next != nil &amp;&amp; p.value != val{    temp = p    p = p.next}if p.value == val{    if p == head{        head = temp.next    }else{        temp.next = p.next    }}return head</code></pre><p>  }<br>  //插入节点<br>  func (this <em>ListNode)InsertNode(head</em> ListNode,val int)*ListNode{</p><pre><code>if head == nil{    return}xNode := new(ListNode)xNode.value = valxNode.next = niltemp := new(ListNode)p := new(ListNode)p = headfor p.next != nil &amp;&amp; p.value &lt; val{    temp = p    p = p.next}if p.value &lt;= val{    if p == head{        head = xNode        xNode.next = p    }else{        temp.next = xNode        xNode.next = p    }}else{    p.next = xNode    xNode.next = nil}return head</code></pre><p>  }<br>  //链表倒置<br>  func (this <em>ListNode)Reverse(head</em> ListNode)*ListNode{</p><pre><code>if head==nil{    return nil}temp := new(ListNode)p := new(ListNode)p = head.nexthead.next=nilfor p != nil{    temp = temp.next    temp.next = head    head = p    p = temp}return head</code></pre><p>  }</p></li></ul><p></p><p></p><ul><li><p>c++</p><p><br><br>  struct ListNode{<br><br>      ListNode <em>next;<br>      int val;<br><br>  }<br>  class Solution{<br>  public:<br>      ListNode</em> CreateListNode(){<br><br>          ListNode<em> head =new ListNode;<br>          p = head;<br>          for (int i =0; i &lt;10; i++){<br>              ListNode</em> node =new ListNode;<br>              node -&gt; next =NULL;<br>              node -&gt; val = i;<br>              p-&gt;next = node;<br>              p = node;<br>          }<br>          p-&gt;next = NULL;<br>          return head;<br><br>      }<br>      ListNode<em> DeletedListNode(ListNode</em> head,int val){<br>          if head == NULL{<br>              return NULL;<br>          }<br>          ListNode<em> temp = NULL;<br>          ListNode</em> p = head;<br>          while(p-&gt;next != NULL &amp;&amp; p-&gt;val != val){<br>              temp = p;<br>              p = p-&gt;next;<br>          }<br>          if (p-&gt;val == val){<br>              if (p == head){<br>                  head = p-&gt;next;<br>                  delete p;<br>              }<br>              else{<br>                  temp-&gt;next = p-&gt;next;<br>                  delete p;<br>              }<br>          }<br>          return head;<br>      }<br>      ListNode<em> InsertListNode(ListNode</em> head,int val){<br><br>          ListNode<em> p = head;<br>          ListNode</em> temp = NULL;<br><br>          ListNode<em> node = new ListNode;<br>          node-&gt;val = val;<br><br>          while(p-&gt;next != NULL &amp;&amp; p-&gt;val &lt; node-&gt;val){<br>              temp = p;<br>              p= p-&gt;next;<br>          }<br>          if (node-&gt;val &lt;= p-&gt;val){<br>              if (p == head){//头部插入<br>                  head = node;<br>                  node -&gt; next = p;<br>              }else{//中间插入<br>                  temp -&gt; next = node;<br>                  node -&gt; next = p;<br>              }<br>          }else{//链表尾部插入<br>              p-&gt;next = node;<br>              node-&gt;next = NULL;<br>          }<br>          return head;<br>      }<br>      ListNode</em> ReverseListNode(ListNode<em> head){<br>          if (head == NULL){<br>              return NULL;<br>          }<br>          ListNode</em> temp = NULL;<br>          ListNode<em> p = head;<br>          head-&gt;next = NULL;<br>          while(p!=NULL){<br>              temp = p-&gt;next;<br>              p-&gt;next = head;<br>              head = p;<br>              p = temp;<br>          }<br>          return head;<br>      }<br>      ListNode</em> DeleteListNode(ListNode<em> head,int val){<br><br>          if (head == NULL) return NULL;<br>          ListNode</em> temp = NULL;<br>          ListNode<em> p = head;<br>          while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL){<br>          temp = p;<br>          p = p-&gt;next;<br>          }<br>          if (p-&gt;val == val){<br>              if (p == head){<br>              head = p-&gt;next;<br>              delete p;<br>              }else{<br>                  temp-&gt;next = p-&gt;next;<br>                  delete p;<br>              }<br>          }<br>      return head;<br>      }<br>      ListNode</em> InsertListNode(ListNode<em> head,int val){<br><br>          ListNode</em> temp = NULL;<br>          ListNode<em> p = head;<br><br>          ListNode</em> newNode = new ListNode;<br>          newNode-&gt;val = val;<br><br>          while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL){<br>          temp = p;<br>          p = p-&gt;next;<br>          }<br>          if (p-&gt;val &lt;= newNode-&gt;val ){<br>              if(p == head){<br>                  head = newNode;<br>                  newNode-&gt;next = p;<br>              }else{<br>                  temp-&gt;next = newNode;<br>                  newNode-&gt;next = p;<br>              }<br><br>          }else{//尾部插入<br>              p-&gt;next = newNode;<br>              newNode-&gt;next = NULL;<br>          }<br>      }<br>  }<br></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单链表的创建、插入、删除-倒置&quot;&gt;&lt;a href=&quot;#单链表的创建、插入、删除-倒置&quot; class=&quot;headerlink&quot; title=&quot;单链表的创建、插入、删除 倒置&quot;&gt;&lt;/a&gt;单链表的创建、插入、删除 倒置&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>http相关特性</title>
    <link href="http://yoursite.com/2018/09/29/http/"/>
    <id>http://yoursite.com/2018/09/29/http/</id>
    <published>2018-09-29T09:15:21.013Z</published>
    <updated>2018-10-25T11:46:37.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http通信的过程"><a href="#http通信的过程" class="headerlink" title="http通信的过程"></a>http通信的过程</h3><p>(1) 建立tcp链接<br>(2) web浏览器向web服务器发送请求命令<br>(3) web浏览器发送请求头消息<br>(4) web服务器应答<br>(5) web服务器发送应答头消息<br>(6) web服务器向浏览器发送数据<br>(7) web服务器关闭tcp链接  </p><h3 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h3><p>1.新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p>2.多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p>3.header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>4.服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;http通信的过程&quot;&gt;&lt;a href=&quot;#http通信的过程&quot; class=&quot;headerlink&quot; title=&quot;http通信的过程&quot;&gt;&lt;/a&gt;http通信的过程&lt;/h3&gt;&lt;p&gt;(1) 建立tcp链接&lt;br&gt;(2) web浏览器向web服务器发送请求命令&lt;br&gt;
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>first-blog</title>
    <link href="http://yoursite.com/2018/09/28/first-blog/"/>
    <id>http://yoursite.com/2018/09/28/first-blog/</id>
    <published>2018-09-28T07:23:00.411Z</published>
    <updated>2018-09-29T11:15:32.651Z</updated>
    
    <content type="html"><![CDATA[<ul><li>welcome to my first blog, to be continued 。。。。。。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;welcome to my first blog, to be continued 。。。。。。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="Hello" scheme="http://yoursite.com/categories/Hello/"/>
    
    
  </entry>
  
</feed>
