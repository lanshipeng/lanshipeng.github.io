<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql数据库使用规范总结]]></title>
    <url>%2F2018%2F10%2F26%2Fsql%2F</url>
    <content type="text"><![CDATA[基本规范 表存储引擎设置为innodb 表字符集默认使用utf8,必要时使用utf8mb4。utf8mb4是utf8的超集,有存储4字节例如表情符号时使用他。 禁止数据库中存储大文件,例如照片.可以将大文件存储在对象存储系统中。数据库存储路径 一般不使用存储过程、视图、触发器,event.对数据库性能影响大，调试，排错，迁移都比较困难.拓展性差 对于互联网业务，能让站点层和服务层干的事,不要交到数据库 命名规范 库名，表名,列名都必须小写,采用下划线分割 库名，表名,列名最好见名知意。长度不超过32个字符 库备份以bak为前缀，日期为后缀 从库以-s为后缀 备库以-ss为后缀 建表规范 单实例表个数控制在2000个以内 单表分表个数控制在1024个以内 表必须有主键，一般使用unsigned整数类型为主键 删除无主键的表,如果是row模式的主从架构。从库会挂住 一般不使用外键,如果要保证完整性。应该由应用程式实现 外键使得表之间相互耦合，影响update/delete性能.有可能造成死锁 建议将大字段,访问频率少的字段拆分到单独表中存储，分离冷热数据 列设计规范 根据业务区分使用tinyint/int/bigint,分别占用1/4/8字节 根据业务区分使用char/varchar 字段长度固定,或者长度近似的业务场景,适用char,能减少碎片,查询性能高 字段长度相差大，或者更新少的业务场景，适合使用varchar,可以减少空间 根据业务区分使用datetime/timestamp(分别占5/4字节) 把not null字段设置为默认值.因为null的列使用索引统计,值都更加复杂。更难优化。只能使用is null 或者is not null 而在=/!=/in/not in有大坑 使用int unsigned 存储ipv4 ,不要用char(15). 使用varchar(20)存储手机号,不要用整数 varchar可以模糊查询 索引规范 唯一索引使用uniq_[字段名]来命名 非唯一索引使用idx_[字段名]来命名 单张表索引数量控制在5个以内 太多索引影响写性能;生成执行计划时,如果索引太多,会降低性能.并可能导致mysql选择不到最优索引 组合索引字段数建议不超过5个 不建议在频繁更新的字段上建立索引 非必要不用join查询，如果要join查询,被join的字段必须类型相同,并建立索引 组合索引最前缀原则,避免重复建索引,如果建立了(a,b,c)相当于建立了(a),(a,b),(a,b,c) sql书写规范 尽量不写select *，只获取必要字段.否则会增加cpu/io/内存/带宽的消耗 同一个字段上的or改写成in,in的值要少于50个 应用程序捕获sql异常，方便定位线上问题 insert必须指定字段,禁止使用insert into table values() 尽量不对大表join和子查询 建表实例1234567891011121314CREATE TABLE `user` (`user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;会员信息表主键，自增长&apos;,`uuid` bigint(20) DEFAULT &apos;0&apos; COMMENT &apos;会员唯一标识表主键，自增长&apos;,`guid` bigint(20) DEFAULT &apos;0&apos; COMMENT &apos;用户中心全局ID&apos;,`is_certed` tinyint(4) DEFAULT &apos;2&apos; COMMENT &apos;是否认证，1 认证 2 未认证&apos;,`mobile` varchar(40) COLLATE utf8mb4_bin NOT NULL COMMENT &apos;手机号码&apos;,`last_login_tm` datetime(6) DEFAULT &apos;0000-00-00 00:00:00.000000&apos; COMMENT &apos;最后一次登录时间&apos;,`last_login_device` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL COMMENT &apos;最后一次登录设备号&apos;,`remark` varchar(250) COLLATE utf8mb4_bin DEFAULT &apos;&apos; COMMENT &apos;备注&apos;,`is_deleted` tinyint(4) DEFAULT &apos;1&apos; COMMENT &apos;是否删除，1 未删除，2 已删除&apos;,`created_tm` datetime(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT &apos;创建时间，默认是 CURRENT_TIMESTAMP(6)&apos;,`updated_tm` datetime(6) DEFAULT &apos;0000-00-00 00:00:00.000000&apos; ON UPDATE CURRENT_TIMESTAMP(6) COMMENT &apos;修改时间，修改时 CURRENT_TIMESTAMP(6)&apos;,PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=241157 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT=&apos;会员信息表&apos;;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F10%2F25%2Fsort%2F</url>
    <content type="text"><![CDATA[golang 实现归并和堆排序1.归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport &quot;fmt&quot;func main()&#123; a := make([]int,0,0) r := make([]int,0,0) a = []int&#123;4,1,3,2,6,5,7&#125; r = []int&#123;0,0,0,0,0,0,0&#125; mergesort(a,0,6,r) fmt.Println(a) fmt.Println(r)&#125;func Swap(a *int,b *int)&#123; temp := *a *a = *b *b = temp&#125;func mergesort(a []int,start,end int64,result []int)&#123; if end - start == 0&#123; return &#125; if end - start == 1&#123; if a[start] &gt; a[end]&#123; Swap(&amp;a[start],&amp;a[end]) &#125; &#125;else&#123; mergesort(a,start,(end-start+1)/2 + start,result) mergesort(a,(end-start+1)/2 +1 + start,end,result) merge(a,start,end,result) var i int64 =0 for i=start;i&lt;=end;i++&#123; a[i] = result[i] &#125; &#125;&#125;func merge(a []int,start,end int64,result []int)&#123; left_index := start left_length := (end-start+1)/2 +1 right_index := start + left_length result_index := start for left_index &lt; start + left_length &amp;&amp; right_index &lt; end+1 &#123; if a[left_index] &lt;= a[right_index]&#123; result[result_index] = a[left_index] result_index++ left_index++ &#125;else&#123; result[result_index] = a[right_index] right_index++ result_index++ &#125; &#125; for left_index &lt; start +left_length&#123; result[result_index] = a[left_index] result_index++ left_index++ &#125; for right_index &lt; end+1&#123; result[result_index] = a[right_index] right_index++ result_index++ &#125;&#125; 2.堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport &quot;fmt&quot;func main()&#123; a := make([]int,0,0) a = []int&#123;1,4,2,3,7,9,8&#125; heapsort(a) fmt.Println(a)&#125;func swap(a *int,b *int)&#123; temp := *a *a = *b *b = temp&#125;func heapsort(a []int)&#123; //创建大顶堆 var i int = 0 var j int = 0 for i= len(a)/2;i&gt;=0;i--&#123; heapadjust(a,i,len(a)) &#125; for j= len(a) -1 ;j&gt;=1;j--&#123; swap(&amp;a[0],&amp;a[j]) heapadjust(a,0,j) &#125;&#125;func heapadjust(a []int,i,length int)&#123; var left int = 2*i +1 if left &lt; length&#123; maxIndex := left right := left + 1 if a[right] &gt; a[left] &amp;&amp; right &lt; length&#123; maxIndex = right &#125; if a[maxIndex] &gt; a[i]&#123; swap(&amp;a[maxIndex],&amp;a[i]) heapadjust(a,maxIndex,length) &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表]]></title>
    <url>%2F2018%2F10%2F25%2Flist%2F</url>
    <content type="text"><![CDATA[单链表的创建、插入、删除 倒置 go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889type ListNode struct&#123; value int next *ListNode&#125;//创建单链表func (this *ListNode)CreateList()*ListNode&#123; head := new(ListNode) ptail := new(ListNode) ptail = head for i :=0; i &lt;= 10; i++&#123; xNode := new(ListNode) xNode.value = i xNode.next = nil ptail.next = xNode ptail = xNode &#125; return phead&#125;//删除节点func (this *ListNode)DeleteListNod(head* ListNode,val int)&#123; if head == nil&#123; return nil &#125; temp := new(ListNode) p := new(ListNode) p = head for p.next != nil &amp;&amp; p.value != val&#123; temp = p p = p.next &#125; if p.value == val&#123; if p == head&#123; head = temp.next &#125;else&#123; temp.next = p.next &#125; &#125; return head&#125;//插入节点func (this *ListNode)InsertNode(head* ListNode,val int)*ListNode&#123; if head == nil&#123; return &#125; xNode := new(ListNode) xNode.value = val xNode.next = nil temp := new(ListNode) p := new(ListNode) p = head for p.next != nil &amp;&amp; p.value &lt; val&#123; temp = p p = p.next &#125; if p.value &lt;= val&#123; if p == head&#123; head = xNode xNode.next = p &#125;else&#123; temp.next = xNode xNode.next = p &#125; &#125;else&#123; p.next = xNode xNode.next = nil &#125; return head&#125;//链表倒置func (this *ListNode)Reverse(head* ListNode)*ListNode&#123; if head==nil&#123; return nil &#125; temp := new(ListNode) p := new(ListNode) p = head.next head.next=nil for p != nil&#123; temp = temp.next temp.next = head head = p p = temp &#125; return head&#125; c++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133struct ListNode&#123; ListNode *next; int val;&#125;class Solution&#123;public: ListNode* CreateListNode()&#123; ListNode* head =new ListNode; p = head; for (int i =0; i &lt;10; i++)&#123; ListNode* node =new ListNode; node -&gt; next =NULL; node -&gt; val = i; p-&gt;next = node; p = node; &#125; p-&gt;next = NULL; return head; &#125; ListNode* DeletedListNode(ListNode* head,int val)&#123; if head == NULL&#123; return NULL; &#125; ListNode* temp = NULL; ListNode* p = head; while(p-&gt;next != NULL &amp;&amp; p-&gt;val != val)&#123; temp = p; p = p-&gt;next; &#125; if (p-&gt;val == val)&#123; if (p == head)&#123; head = p-&gt;next; delete p; &#125; else&#123; temp-&gt;next = p-&gt;next; delete p; &#125; &#125; return head; &#125; ListNode* InsertListNode(ListNode* head,int val)&#123; ListNode* p = head; ListNode* temp = NULL; ListNode* node = new ListNode; node-&gt;val = val; while(p-&gt;next != NULL &amp;&amp; p-&gt;val &lt; node-&gt;val)&#123; temp = p; p= p-&gt;next; &#125; if (node-&gt;val &lt;= p-&gt;val)&#123; if (p == head)&#123;//头部插入 head = node; node -&gt; next = p; &#125;else&#123;//中间插入 temp -&gt; next = node; node -&gt; next = p; &#125; &#125;else&#123;//链表尾部插入 p-&gt;next = node; node-&gt;next = NULL; &#125; return head; &#125; ListNode* ReverseListNode(ListNode* head)&#123; if (head == NULL)&#123; return NULL; &#125; ListNode* temp = NULL; ListNode* p = head; head-&gt;next = NULL; while(p!=NULL)&#123; temp = p-&gt;next; p-&gt;next = head; head = p; p = temp; &#125; return head; &#125; ListNode* DeleteListNode(ListNode* head,int val)&#123; if (head == NULL) return NULL; ListNode* temp = NULL; ListNode* p = head; while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL)&#123; temp = p; p = p-&gt;next; &#125; if (p-&gt;val == val)&#123; if (p == head)&#123; head = p-&gt;next; delete p; &#125;else&#123; temp-&gt;next = p-&gt;next; delete p; &#125; &#125; return head; &#125; ListNode* InsertListNode(ListNode* head,int val)&#123; ListNode* temp = NULL; ListNode* p = head; ListNode* newNode = new ListNode; newNode-&gt;val = val; while(val &lt; p-&gt;val &amp;&amp; p-&gt;next !=NULL)&#123; temp = p; p = p-&gt;next; &#125; if (p-&gt;val &lt;= newNode-&gt;val )&#123; if(p == head)&#123; head = newNode; newNode-&gt;next = p; &#125;else&#123; temp-&gt;next = newNode; newNode-&gt;next = p; &#125; &#125;else&#123;//尾部插入 p-&gt;next = newNode; newNode-&gt;next = NULL; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http相关特性]]></title>
    <url>%2F2018%2F10%2F25%2Fhttp%2F</url>
    <content type="text"><![CDATA[http通信的过程(1) 建立tcp链接(2) web浏览器向web服务器发送请求命令(3) web浏览器发送请求头消息(4) web服务器应答(5) web服务器发送应答头消息(6) web服务器向浏览器发送数据(7) web服务器关闭tcp链接 HTTP2.0和HTTP1.X相比的新特性1.新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 2.多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 3.header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 4.服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 http url 字符含义 URL特殊符号及对应的十六进制值编码： ‘+’ URL中+号表示空格 %2B 空格 URL中的空格可以用+号或者编码 %20 / 分隔目录和子目录 %2F ? 分隔实际的 URL 和参数 %3F % 指定特殊字符 %25 ‘#’ 表示书签 %23 &amp; URL中指定的参数间的分隔符 %26 = URL中指定参数的值 %3D]]></content>
      <categories>
        <category>协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2018%2F09%2F29%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[welcome to my first blog, to be continued 。。。。。。 hah]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
</search>
